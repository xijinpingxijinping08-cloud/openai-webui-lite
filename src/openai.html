<!doctype html>
<html lang="zh-Hans">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#605bec" />
    <meta name="description" content="OpenAI Chat - æ™ºèƒ½å¯¹è¯åŠ©æ‰‹" />
    <meta http-equiv="Content-Language" content="zh-CN" />
    <title>OpenAI Chat</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />

    <!-- Web App Manifest -->
    <link rel="manifest" href="site.webmanifest" />

    <!-- iOS Safari -->
    <link rel="apple-touch-icon" href="favicon.svg" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="OpenAI Chat" />

    <script src="https://unpkg.com/tom-select@2.4.3/dist/js/tom-select.complete.min.js"></script>

    <script src="https://unpkg.com/vue@3.5.22/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/sweetalert2@11.26.3/dist/sweetalert2.all.js"></script>
    <script src="https://unpkg.com/marked@12.0.0/marked.min.js"></script>
    <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <link
      href="https://unpkg.com/tom-select@2.4.3/dist/css/tom-select.default.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/github-markdown-css@5.8.1/github-markdown-light.css"
    />
    <!-- CSS: style.css -->
    <link rel="stylesheet" href="style.css" />
    <script>
      var isWechat = new RegExp('wechat', 'i').test(window.navigator.userAgent);
      if (isWechat && document.title) {
        document.title = 'âœ¨ ' + document.title;
      }
      // IndexedDB å°è£…ï¼ˆæ”¯æŒWebDAVè¿œç¨‹å­˜å‚¨ï¼‰
      class OpenaiDB {
        constructor() {
          this.dbName = 'OpenaiChatDB';
          this.version = 1;
          this.storeName = 'chatData';
          this.db = null;
          // WebDAV é…ç½®
          this.webdavEnabled = false;
          this.webdavConfig = {
            url: '',
            username: '',
            password: '',
            path: '/openai-chat/'
          };
        }

        // åŠ è½½WebDAVé…ç½®ï¼ˆä»IndexedDBï¼‰
        async loadWebDAVConfig() {
          if (!this.db) await this.init();
          try {
            var configStr = await this.getItem('openai_webdav_config');
            if (configStr) {
              var parsed = JSON.parse(configStr);
              this.webdavEnabled = parsed.enabled || false;
              this.webdavConfig = parsed.config || this.webdavConfig;
            }
          } catch (e) {
            console.error('è§£æWebDAVé…ç½®å¤±è´¥:', e);
          }
        }

        // ä¿å­˜WebDAVé…ç½®ï¼ˆåˆ°IndexedDBï¼‰
        async saveWebDAVConfig(enabled, config) {
          this.webdavEnabled = enabled;
          this.webdavConfig = config;
          // ç›´æ¥å†™å…¥IndexedDBï¼Œä¸èµ°setItemï¼ˆé¿å…è§¦å‘WebDAVåŒæ­¥ï¼‰
          if (!this.db) await this.init();
          return new Promise((resolve, reject) => {
            var transaction = this.db.transaction(
              [this.storeName],
              'readwrite'
            );
            var store = transaction.objectStore(this.storeName);
            var request = store.put({
              key: 'openai_webdav_config',
              value: JSON.stringify({ enabled: enabled, config: config })
            });
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve();
          });
        }

        // æ„å»ºWebDAVä»£ç†URL
        _buildProxyUrl(targetPath) {
          // é€šè¿‡ /webdav ä»£ç†æ¥å£è½¬å‘è¯·æ±‚
          return '/webdav' + targetPath;
        }

        // æ„å»ºWebDAVä»£ç†è¯·æ±‚å¤´
        _buildProxyHeaders(config, extraHeaders = {}) {
          var baseUrl = config.url.replace(/\/$/, '');
          var headers = {
            'X-WebDAV-URL': baseUrl,
            'X-WebDAV-Auth':
              'Basic ' + btoa(config.username + ':' + config.password)
          };
          return Object.assign(headers, extraHeaders);
        }

        // æµ‹è¯•WebDAVè¿æ¥ï¼ˆä½¿ç”¨ PUT/GET/DELETE æ–¹å¼ï¼Œå…¼å®¹æ€§æ›´å¥½ï¼‰
        async testWebDAVConnection(config) {
          var testFileName = '.webdav-test-' + Date.now() + '.txt';
          var testContent = 'test-' + Date.now();
          var regexp = new RegExp('\/$');
          var targetPath = config.path.replace(regexp, '') + '/' + testFileName;
          var proxyUrl = this._buildProxyUrl(targetPath);
          var headers = this._buildProxyHeaders(config, {
            'Content-Type': 'text/plain'
          });

          try {
            // æ­¥éª¤1: å°è¯•å†™å…¥æµ‹è¯•æ–‡ä»¶
            var putResponse = await fetch(proxyUrl, {
              method: 'PUT',
              headers: headers,
              body: testContent
            });

            // 401 è¡¨ç¤ºè®¤è¯å¤±è´¥
            if (putResponse.status === 401) {
              return { success: false, error: 'è®¤è¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·åå’Œå¯†ç ' };
            }

            // 403 è¡¨ç¤ºæ²¡æœ‰å†™å…¥æƒé™
            if (putResponse.status === 403) {
              return { success: false, error: 'æ²¡æœ‰å†™å…¥æƒé™' };
            }

            // PUT æˆåŠŸçš„çŠ¶æ€ç : 200, 201, 204
            if (![200, 201, 204].includes(putResponse.status)) {
              return {
                success: false,
                error:
                  'å†™å…¥æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç›®å½•æ˜¯å¦å·²åˆ›å»º: HTTP ' +
                  putResponse.status
              };
            }

            // æ­¥éª¤2: å°è¯•è¯»å–æµ‹è¯•æ–‡ä»¶
            var getHeaders = this._buildProxyHeaders(config);
            var getResponse = await fetch(proxyUrl, {
              method: 'GET',
              headers: getHeaders
            });

            if (getResponse.status !== 200) {
              return {
                success: false,
                error: 'è¯»å–æµ‹è¯•å¤±è´¥: HTTP ' + getResponse.status
              };
            }

            var readContent = await getResponse.text();
            if (readContent !== testContent) {
              return { success: false, error: 'æ•°æ®éªŒè¯å¤±è´¥' };
            }

            // æ­¥éª¤3: åˆ é™¤æµ‹è¯•æ–‡ä»¶ï¼ˆæ¸…ç†ï¼‰
            var deleteHeaders = this._buildProxyHeaders(config);
            await fetch(proxyUrl, {
              method: 'DELETE',
              headers: deleteHeaders
            });
            // åˆ é™¤å¤±è´¥ä¹Ÿä¸å½±å“æµ‹è¯•ç»“æœï¼Œå¿½ç•¥é”™è¯¯

            return { success: true };
          } catch (e) {
            return { success: false, error: e.message || 'ç½‘ç»œé”™è¯¯' };
          }
        }

        // WebDAV è¯»å–æ–‡ä»¶
        async webdavGet(filename) {
          var targetPath = this.webdavConfig.path + filename;
          var proxyUrl = this._buildProxyUrl(targetPath);
          var headers = this._buildProxyHeaders(this.webdavConfig);
          try {
            var response = await fetch(proxyUrl, {
              method: 'GET',
              headers: headers
            });
            if (response.status === 200) {
              return await response.text();
            } else if (response.status === 404) {
              return null;
            } else {
              console.error('WebDAV GET å¤±è´¥:', response.status);
              return null;
            }
          } catch (e) {
            console.error('WebDAV GET é”™è¯¯:', e);
            return null;
          }
        }

        // WebDAV å†™å…¥æ–‡ä»¶
        async webdavPut(filename, content) {
          var targetPath = this.webdavConfig.path + filename;
          var proxyUrl = this._buildProxyUrl(targetPath);
          var headers = this._buildProxyHeaders(this.webdavConfig, {
            'Content-Type': 'application/json'
          });
          try {
            var response = await fetch(proxyUrl, {
              method: 'PUT',
              headers: headers,
              body: content
            });
            return (
              response.status === 200 ||
              response.status === 201 ||
              response.status === 204
            );
          } catch (e) {
            console.error('WebDAV PUT é”™è¯¯:', e);
            return false;
          }
        }

        // WebDAV é˜²æŠ–åŒæ­¥ï¼ˆå‡å°‘é¢‘ç¹å†™å…¥ï¼‰
        _debouncedWebdavSync(value) {
          this._pendingWebdavData = value;
          if (this._webdavSyncTimer) {
            clearTimeout(this._webdavSyncTimer);
          }
          this._webdavSyncTimer = setTimeout(async () => {
            if (this._pendingWebdavData) {
              console.log('[WebDAV] åŒæ­¥æ•°æ®åˆ°è¿œç¨‹...');
              var success = await this.webdavPut(
                'sessions.json',
                this._pendingWebdavData
              );
              if (!success) {
                console.error('[WebDAV] åŒæ­¥å¤±è´¥');
              } else {
                console.log('[WebDAV] åŒæ­¥æˆåŠŸ');
              }
              this._pendingWebdavData = null;
            }
            this._webdavSyncTimer = null;
          }, 5000); // 5ç§’é˜²æŠ–
        }

        // ç«‹å³åŒæ­¥åˆ° WebDAVï¼ˆç”¨äºé¡µé¢å…³é—­å‰ç­‰åœºæ™¯ï¼‰
        async flushWebdavSync() {
          if (this._webdavSyncTimer) {
            clearTimeout(this._webdavSyncTimer);
            this._webdavSyncTimer = null;
          }
          if (this._pendingWebdavData && this.webdavEnabled) {
            console.log('[WebDAV] ç«‹å³åŒæ­¥æ•°æ®...');
            await this.webdavPut('sessions.json', this._pendingWebdavData);
            this._pendingWebdavData = null;
          }
        }

        async init() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);

            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
              this.db = request.result;
              resolve(this.db);
            };

            request.onupgradeneeded = event => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains(this.storeName)) {
                db.createObjectStore(this.storeName, { keyPath: 'key' });
              }
            };
          });
        }

        async setItem(key, value) {
          // å…ˆå†™å…¥æœ¬åœ° IndexedDBï¼ˆä¿è¯æ•°æ®å®‰å…¨ï¼‰
          if (!this.db) await this.init();

          await new Promise((resolve, reject) => {
            const transaction = this.db.transaction(
              [this.storeName],
              'readwrite'
            );
            const store = transaction.objectStore(this.storeName);
            const request = store.put({ key, value });

            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve();
          });

          // å¦‚æœæ˜¯sessionsä¸”å¯ç”¨äº†WebDAVï¼Œåˆ™ä½¿ç”¨é˜²æŠ–åŒæ­¥åˆ°è¿œç¨‹
          if (key === 'openai_sessions' && this.webdavEnabled) {
            this._debouncedWebdavSync(value);
          }
        }

        async getItem(key) {
          // å¦‚æœæ˜¯sessionsä¸”å¯ç”¨äº†WebDAVï¼Œåˆ™ä»è¿œç¨‹è¯»å–
          if (key === 'openai_sessions' && this.webdavEnabled) {
            // è®¾ç½®åŠ è½½çŠ¶æ€
            if (window.app) window.app.isLoadingRemoteSessions = true;
            try {
              // 120ç§’å†…çš„ç¼“å­˜æœ‰æ•ˆ
              const timestamp = Math.floor(Date.now() / 1000 / 120);
              var remoteData = await this.webdavGet(
                'sessions.json?v=' + timestamp
              );
              if (remoteData !== null) {
                if (window.app) {
                  window.app.showToast('è¿œç¨‹æ•°æ®å·²åŠ è½½', 'success');
                }
                return remoteData;
              }
              // å¦‚æœè¿œç¨‹æ²¡æœ‰æ•°æ®ï¼Œå›é€€åˆ°æœ¬åœ°
              console.log('WebDAVæ— æ•°æ®ï¼Œå°è¯•ä»æœ¬åœ°è¯»å–');
            } finally {
              if (window.app) window.app.isLoadingRemoteSessions = false;
            }
          }

          if (!this.db) await this.init();

          return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(
              [this.storeName],
              'readonly'
            );
            const store = transaction.objectStore(this.storeName);
            const request = store.get(key);

            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
              const result = request.result;
              resolve(result ? result.value : null);
            };
          });
        }

        // è®¡ç®—IndexedDBå­˜å‚¨ç©ºé—´å¤§å°ï¼ˆMBï¼‰
        async getTotalDataSize() {
          if (!this.db) await this.init();

          return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(
              [this.storeName],
              'readonly'
            );
            const store = transaction.objectStore(this.storeName);
            const request = store.getAll();

            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
              const allData = request.result;
              let totalSize = 0;

              // è®¡ç®—æ‰€æœ‰æ•°æ®çš„JSONå­—ç¬¦ä¸²å¤§å°
              allData.forEach(item => {
                const jsonString = JSON.stringify(item);
                // ä½¿ç”¨UTF-8ç¼–ç è®¡ç®—å­—èŠ‚æ•°
                totalSize += new Blob([jsonString]).size;
              });

              // è½¬æ¢ä¸ºMB
              const sizeInMB = totalSize / (1024 * 1024);
              resolve(sizeInMB);
            };
          });
        }

        // è·å–å­˜å‚¨ç©ºé—´ç»Ÿè®¡ä¿¡æ¯
        async getStorageStats() {
          if (!this.db) await this.init();

          const stats = {
            totalSizeMB: 0,
            itemCount: 0,
            largestItemKey: '',
            largestItemSizeMB: 0
          };

          return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(
              [this.storeName],
              'readonly'
            );
            const store = transaction.objectStore(this.storeName);
            const request = store.getAll();

            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
              const allData = request.result;
              let totalSize = 0;
              let maxSize = 0;
              let maxKey = '';

              allData.forEach(item => {
                const jsonString = JSON.stringify(item);
                const itemSize = new Blob([jsonString]).size;
                totalSize += itemSize;

                if (itemSize > maxSize) {
                  maxSize = itemSize;
                  maxKey = item.key || 'unknown';
                }
              });

              stats.totalSizeMB = totalSize / (1024 * 1024);
              stats.itemCount = allData.length;
              stats.largestItemKey = maxKey;
              stats.largestItemSizeMB = maxSize / (1024 * 1024);

              resolve(stats);
            };
          });
        }
      }

      // å…¨å±€å®ä¾‹
      window.openaiDB = new OpenaiDB();
    </script>
  </head>

  <body>
    <div id="app">
      <!-- ç§»åŠ¨ç«¯èœå•æŒ‰é’® -->
      <button
        v-cloak
        v-show="isMobile"
        class="mobile-menu-btn"
        style="display: none"
        @click="toggleSidebar"
      >
        {{ !showSidebar ? 'â˜°' : 'ï¼œ' }}
      </button>
      <!-- ç§»åŠ¨ç«¯é®ç½©å±‚ -->
      <div
        class="sidebar-overlay"
        :class="{ show: showSidebar && isMobile }"
        v-cloak
        @click="hideSidebar"
      ></div>
      <div class="container" :class="{ wide: isWideMode }">
        <!-- ä¾§è¾¹æ  -->
        <div
          v-show="true"
          class="sidebar"
          :class="{ show: showSidebar || !isMobile, mobile: isMobile }"
          v-cloak
          style="display: none"
        >
          <!-- è®¾ç½®æŒ‰é’® -->
          <div class="settings-section">
            <button
              class="settings-btn"
              :class="{ mobile: isMobile }"
              @click="openSettingsModal()"
            >
              âš™ï¸ è®¾ç½®
              <span v-if="!apiKey" style="color: #e74c3c; margin-left: 4px"
                >(æœªé…ç½®)</span
              >
              <span
                v-else-if="storageMode === 'webdav'"
                style="color: #5fbdbd; margin-left: 4px"
                >(è¿œç¨‹å­˜å‚¨)</span
              >
            </button>
          </div>
          <!-- è§’è‰²è®¾å®š -->
          <div v-show="!isLoadingRemoteSessions" class="role-setting">
            <label
              for="rolePrompt"
              style="
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
                font-weight: 500;
              "
            >
              <span>
                <span>è§’è‰²è®¾å®š&nbsp;</span>
                <span v-if="!globalRolePromptEnabled">(å·²ç¦ç”¨):</span>
                <span v-else-if="!globalRolePrompt">(å¯é€‰):</span>
                <span v-else="">(å·²å¯ç”¨):</span>
              </span>
              <span>
                <button
                  class="reset-btn"
                  style="
                    width: 0;
                    padding-left: 0;
                    padding-right: 0;
                    margin-left: 0;
                    visibility: hidden;
                    pointer-events: none;
                  "
                >
                  ã€€
                </button>
                <button
                  v-if="globalRolePrompt && globalRolePromptEnabled"
                  class="reset-btn"
                  @click="clearRolePrompt"
                  title="æ¸…ç©ºè§’è‰²è®¾å®š"
                >
                  æ¸…ç©º
                </button>
                <button
                  v-if="globalRolePrompt"
                  class="reset-btn"
                  :title="globalRolePromptEnabled ? 'ç¦ç”¨è§’è‰²è®¾å®š' : 'å¯ç”¨è§’è‰²è®¾å®š'"
                  @click="toggleRolePrompt()"
                >
                  {{ globalRolePromptEnabled ? 'ç¦ç”¨' : 'å¯ç”¨' }}
                </button>
              </span>
            </label>
            <textarea
              id="rolePrompt"
              v-model="globalRolePrompt"
              class="role-textarea"
              :disabled="!globalRolePromptEnabled && globalRolePrompt.length > 0"
              placeholder="è¾“å…¥ç³»ç»Ÿæç¤ºè¯æˆ–è§’è‰²è®¾å®š..."
              @input="updateGlobalRolePrompt"
            >
            </textarea>
          </div>
          <!-- æ–°å»ºä¼šè¯æŒ‰é’® -->
          <button
            v-show="!isLoadingRemoteSessions"
            @click="createNewSession"
            class="new-session-btn"
          >
            â• æ–°å»ºä¼šè¯
          </button>
          <!-- ä¼šè¯åˆ—è¡¨ -->
          <div class="sessions">
            <!-- è¿œç¨‹åŠ è½½ä¸­çš„æç¤º -->
            <div
              v-if="isLoadingRemoteSessions"
              class="loading-remote-sessions"
              style="margin-top: calc(50vh - 70px - 104px)"
            >
              <span class="loading-spinner"></span>
              <span>æ­£åœ¨åŠ è½½è¿œç¨‹æ•°æ®...</span>
            </div>
            <div
              v-for="session in sessions"
              v-show="!isLoadingRemoteSessions"
              :key="session.id"
              @click="switchSession(session.id)"
              :class="['session-item', { active: currentSessionId === session.id }]"
              :title="session.summary || session.title || 'æ–°ä¼šè¯'"
            >
              <div class="session-title">
                <span>{{ session.summary || session.title || 'æ–°ä¼šè¯' }}</span>
                <span v-if="session.role">&nbsp;ğŸ’­</span>
              </div>
              <button
                @click.stop="deleteSession(session.id)"
                class="delete-btn"
                title="åˆ é™¤ä¼šè¯"
              >
                Ã—
              </button>
            </div>
          </div>
        </div>
        <!-- ä¸»èŠå¤©åŒºåŸŸ -->
        <div class="main-chat" v-show="true" v-cloak style="display: none">
          <!-- å¤´éƒ¨ -->
          <div class="header">
            <h2 style="cursor: pointer">
              <div class="brand" @click="showAbout">
                <img
                  src="./favicon.svg"
                  alt=""
                  width="24"
                  height="24"
                  style="flex: 0 0 auto; line-height: 1"
                />
                <span>OpenAI Chat</span>
              </div>
            </h2>
            <div class="model-wrap">
              <select
                v-model="selectedModel"
                class="model-select"
                :class="{simple: availableModels.length <= 10}"
                id="selectedModel"
                :disabled="isLoading || isStreaming"
                @change="saveData()"
              >
                <option v-if="false">ã€€</option>
                <option
                  v-for="i in availableModels"
                  :key="i.value"
                  :value="i.value"
                >
                  {{ i.label }}
                </option>
              </select>
              <label for="needSearch" class="model-search-label">
                <input
                  type="checkbox"
                  v-model="needSearch"
                  class="model-search"
                  id="needSearch"
                  @change="saveData()"
                />
                <span>è”ç½‘æœç´¢</span>
              </label>
            </div>
            <div class="tool-btns">
              <button
                v-if="isPC"
                class="tool-btn wide-btn"
                @click="toggleWideMode"
              >
                {{ isWideMode ? '&nbsp;â€º æ”¶çª„ â€¹&nbsp;' : '&nbsp;â€¹ åŠ å®½ â€º&nbsp;'
                }}
              </button>
              <button
                v-if="currentSession && currentSession.messages && currentSession.messages.length > 1 && !isLoading && !isStreaming"
                class="tool-btn share-btn"
                @click="shareSession"
              >
                ğŸ“¸ åˆ†äº«
              </button>
            </div>
          </div>
          <!-- æ¶ˆæ¯åŒºåŸŸ -->
          <div class="messages-container" ref="messagesContainer">
            <div
              v-if="!currentSession || !currentSession.messages || currentSession.messages.length === 0"
              class="empty-state"
            >
              <div
                v-if="isLoadingRemoteSessions"
                class="loading-remote-sessions"
              >
                <span class="loading-spinner"></span>
                <span>æ­£åœ¨åŠ è½½è¿œç¨‹æ•°æ®...</span>
              </div>
              <template v-if="!isLoadingRemoteSessions">
                <h3>å¼€å§‹ä¸ AI å¯¹è¯</h3>
                <p>é€‰æ‹©ä¸€ä¸ªæ¨¡å‹å¹¶è¾“å…¥æ‚¨çš„é—®é¢˜</p>
              </template>
            </div>
            <div
              v-if="currentSession && currentSession.messages && currentSession.messages.length > 0"
              class="session-content"
              :class="{capturing: isCapturing}"
            >
              <!-- è§’è‰²è®¾å®šæ˜¾ç¤º -->
              <div
                v-if="currentSession.role && currentSession.role.trim()"
                class="content-section role-section"
              >
                <h4>
                  <span>
                    <label for="fold">
                      <span>è§’è‰²è®¾å®šã€€</span>
                      <input
                        v-show="!isCapturing"
                        v-model="isFoldRole"
                        type="checkbox"
                        id="fold"
                      />
                      <small v-show="!isCapturing">&nbsp;æŠ˜å </small>
                    </label>
                  </span>
                  <button
                    @click="copyToClipboard(currentSession.role)"
                    class="copy-btn"
                    title="å¤åˆ¶è§’è‰²è®¾å®š"
                  >
                    å¤åˆ¶
                  </button>
                </h4>
                <div
                  class="rendered-content markdown-body"
                  v-html="renderMarkdown(currentSession.role)"
                ></div>
              </div>
              <!-- ä½¿ç”¨v-foræ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨ -->
              <template
                v-for="(msg, msgIndex) in currentSession.messages"
                :key="msgIndex"
              >
                <!-- ç”¨æˆ·æ¶ˆæ¯ -->
                <div
                  v-if="msg.type === 'user'"
                  class="content-section question-section"
                >
                  <h4>
                    <span>
                      <span>{{ getMsgLabel(msg, msgIndex) }}</span>
                      <small v-if="msg.time"
                        >&emsp;{{ formatTimeStr(msg.time) }}</small
                      >
                    </span>
                    <div>
                      <button
                        v-if="canEditMessage(msgIndex)"
                        class="copy-btn"
                        title="ç¼–è¾‘é—®é¢˜"
                        @click="editQuestion(msgIndex)"
                      >
                        ç¼–è¾‘
                      </button>
                      <button
                        @click="copyToClipboard(msg.content)"
                        class="copy-btn"
                        title="å¤åˆ¶é—®é¢˜"
                      >
                        å¤åˆ¶
                      </button>
                    </div>
                  </h4>
                  <div
                    class="rendered-content markdown-body"
                    v-html="renderMarkdown(msg.content)"
                  ></div>
                  <!-- å›¾ç‰‡é“¾æ¥ -->
                  <div
                    v-if="msg.images && msg.images.length > 0"
                    class="question-images"
                  >
                    <a
                      v-for="(img, imgIdx) in msg.images"
                      :key="imgIdx"
                      href="javascript:void(0)"
                      :title="img === 'INVALID' ? 'å›¾ç‰‡æœªä¸Šä¼ ,æ— æ³•é¢„è§ˆ' : 'ç‚¹å‡»é¢„è§ˆ'"
                      :style="img === 'INVALID' ? 'cursor: not-allowed; opacity: 0.5;' : ''"
                      @click="previewImage(img)"
                    >
                      ğŸ“ {{ img === 'INVALID' ? 'æœ¬åœ°' : '' }}å›¾ç‰‡{{ imgIdx + 1
                      }}
                    </a>
                  </div>
                  <!-- æ–‡æœ¬é™„ä»¶é“¾æ¥ -->
                  <div
                    v-if="msg.plaintexts && msg.plaintexts.length > 0"
                    class="question-images"
                  >
                    <a
                      v-for="(txt, txtIdx) in msg.plaintexts"
                      :key="'txt-' + txtIdx"
                      href="javascript:void(0)"
                      title="ç‚¹å‡»é¢„è§ˆå†…å®¹"
                      @click="previewPlaintext(txt)"
                    >
                      ğŸ“„ {{ txt.name }}
                    </a>
                  </div>
                </div>
                <!-- AIå›ç­” -->
                <div
                  v-if="msg.type === 'bot'"
                  class="content-section answer-section"
                >
                  <h4>
                    <span>
                      <span>å›ç­”</span>
                      <small v-if="msg.model"
                        >&emsp;{{ getModelName(msg.model) }}</small
                      >
                    </span>
                    <div v-if="!isStreaming || !isLastBotMsg(msgIndex)">
                      <button
                        v-if="canRegenerateMessage(msgIndex)"
                        class="copy-btn"
                        title="åˆ é™¤å¹¶é‡æ–°å›ç­”"
                        @click="regenerateAnswer(msgIndex)"
                      >
                        é‡æ–°å›ç­”
                      </button>
                      <button
                        v-if="canForkMessage(msgIndex)"
                        class="copy-btn"
                        title="ä»æ­¤å¤„åˆ†å‰åˆ›å»ºæ–°ä¼šè¯"
                        @click="forkFromMessage(msgIndex)"
                      >
                        åˆ†å‰
                      </button>
                      <button
                        class="copy-btn"
                        title="å¤åˆ¶å›ç­”"
                        @click="copyToClipboard(msg.content)"
                      >
                        å¤åˆ¶
                      </button>
                    </div>
                  </h4>
                  <div
                    class="rendered-content markdown-body streaming-answer"
                    v-html="renderMarkdown(getBotMessageContent(msg, msgIndex))"
                    @click="answerClickHandler"
                  ></div>
                </div>
              </template>
              <!-- æµå¼å›ç­”å ä½ï¼ˆå½“æœ€åä¸€æ¡æ˜¯ç”¨æˆ·æ¶ˆæ¯ä¸”æ­£åœ¨ç”Ÿæˆå›å¤æ—¶ï¼‰ -->
              <div
                v-if="isStreamingNewAnswer"
                class="content-section answer-section"
              >
                <h4>
                  <span>
                    <span>å›ç­”</span>
                    <small>&emsp;{{ getModelName(selectedModel) }}</small>
                  </span>
                </h4>
                <div
                  class="rendered-content markdown-body streaming-answer"
                  v-html="renderMarkdown(streamingContent)"
                  @click="answerClickHandler"
                ></div>
              </div>
            </div>
            <div v-if="shouldShowLoading" class="loading">
              <div class="spinner"></div>
              <span>AI æ­£åœ¨æ€è€ƒä¸­...</span>
            </div>

            <div v-if="errorMessage" class="error-message">
              {{ errorMessage }}
            </div>

            <!-- é‡æ–°å›ç­”æŒ‰é’® -->
            <div
              v-if="shouldShowRetryButton"
              style="text-align: center; margin: 0 0 20px"
            >
              <button
                @click="retryCurrentQuestion"
                class="send-btn"
                style="margin: 0 auto"
              >
                â†º é‡æ–°å›ç­”
              </button>
            </div>
          </div>
          <!-- è¾“å…¥åŒºåŸŸ -->
          <div class="input-area">
            <!-- ä¸Šä¼ çš„é™„ä»¶æ ‡ç­¾ï¼ˆå›¾ç‰‡å’Œæ–‡æœ¬æ–‡ä»¶ï¼‰ -->
            <div
              v-if="uploadedImages.length > 0 || uploadedPlaintexts.length > 0"
              class="uploaded-images-tags"
            >
              <!-- å›¾ç‰‡æ ‡ç­¾ -->
              <div
                v-for="(img, index) in uploadedImages"
                :key="'img-' + index"
                class="image-tag"
              >
                <img
                  :src="getImageDisplayUrl(img)"
                  :alt="'å›¾ç‰‡' + (index + 1)"
                />
                <span class="image-tag-text">å›¾ç‰‡{{ index + 1 }}</span>
                <button
                  class="image-tag-remove"
                  @click="removeImage(index)"
                  title="ç§»é™¤å›¾ç‰‡"
                >
                  Ã—
                </button>
              </div>
              <!-- æ–‡æœ¬æ–‡ä»¶æ ‡ç­¾ -->
              <div
                v-for="(txt, index) in uploadedPlaintexts"
                :key="'txt-' + index"
                class="image-tag plaintext-tag"
                @click="previewPlaintext(txt)"
                title="ç‚¹å‡»é¢„è§ˆå†…å®¹"
              >
                <span class="plaintext-icon">ğŸ“„</span>
                <span class="image-tag-text">{{ txt.name }}</span>
                <button
                  class="image-tag-remove"
                  @click.stop="removePlaintext(index)"
                  title="ç§»é™¤æ–‡ä»¶"
                >
                  Ã—
                </button>
              </div>
            </div>

            <div class="input-wrapper">
              <!-- ä¸Šä¼ æŒ‰é’®ï¼ˆå›¾ç‰‡æˆ–æ–‡æœ¬æ–‡ä»¶ï¼‰ -->
              <button
                class="upload-btn"
                @click="triggerUpload"
                :disabled="!canInput || isUploadingImage"
                title="ä¸Šä¼ å›¾ç‰‡æˆ–æ–‡æœ¬æ–‡ä»¶"
              >
                ğŸ“
              </button>
              <input
                type="file"
                ref="imageInput"
                accept="image/*"
                style="display: none"
                @change="handleImageSelect"
              />
              <input
                type="file"
                ref="plaintextInput"
                :accept="getSupportedTextExtensions().join(',')"
                style="display: none"
                @change="handlePlaintextSelect"
              />

              <textarea
                v-model="messageInput"
                @input="onInputChange"
                @keydown="handleKeyDown"
                @paste="handlePaste"
                class="message-input can-upload"
                :placeholder="inputPlaceholder"
                :disabled="!canInput"
                rows="1"
                ref="messageInputRef"
              ></textarea>
              <button
                v-show="messageInput.trim()"
                @click="clearInput"
                class="clear-btn"
                title="æ¸…ç©ºè¾“å…¥"
              >
                Ã—
              </button>
            </div>
            <button
              v-if="isCurrentEnd"
              class="send-btn"
              @click="createNewSession"
            >
              æ–°ä¼šè¯
            </button>
            <button
              v-else-if="(isLoading || isStreaming) && isSentForAWhile"
              class="send-btn danger"
              @click="cancelStreaming"
            >
              ä¸­æ­¢
            </button>
            <button
              v-else
              @click="sendMessage"
              :disabled="!canSend"
              class="send-btn"
            >
              å‘é€
            </button>
          </div>
        </div>
      </div>

      <!-- éšè—çš„æœç´¢ç»“æœæ¨¡æ¿ -->
      <div v-if="searchRes" ref="searchResTemplate" style="display: none">
        <div
          style="
            text-align: left;
            max-height: 70vh;
            overflow-y: auto;
            padding: 10px;
          "
        >
          <!-- æœç´¢æŸ¥è¯¢ -->
          <div style="margin-bottom: 20px">
            <h3 style="margin: 0 0 10px; color: #333; font-size: 16px">
              ğŸ” æœç´¢æŸ¥è¯¢
            </h3>
            <div
              style="
                padding: 12px;
                background: #f8f9fa;
                border-radius: 8px;
                border-left: 4px solid #a8edea;
              "
            >
              <strong style="color: #2d3748; font-size: 15px"
                >{{ searchRes.query }}</strong
              >
            </div>
          </div>

          <!-- AI æ€»ç»“ç­”æ¡ˆ -->
          <div v-if="searchRes.answer" style="margin-bottom: 20px">
            <h3 style="margin: 0 0 10px; color: #333; font-size: 16px">
              ğŸ’¡ AI æ€»ç»“
            </h3>
            <div
              style="
                padding: 12px;
                background: #fff3cd;
                border-radius: 8px;
                border-left: 4px solid #ffc107;
                line-height: 1.6;
                color: #666;
                font-size: 14px;
              "
            >
              {{ searchRes.answer }}
            </div>
          </div>

          <!-- æœç´¢ç»“æœåˆ—è¡¨ -->
          <div v-if="searchRes.results && searchRes.results.length > 0">
            <div style="margin-bottom: 10px">
              <h3 style="margin: 0 0 10px; color: #333; font-size: 16px">
                ğŸ“š æœç´¢ç»“æœ ({{ searchRes.results.length }} æ¡)
              </h3>
            </div>

            <div
              v-for="(result, index) in searchRes.results"
              :key="index"
              style="
                margin-bottom: 15px;
                padding: 15px;
                background: #ffffff;
                border: 1px solid #e1e5e9;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
              "
            >
              <div style="margin-bottom: 8px">
                <span
                  style="
                    display: inline-block;
                    padding: 2px 8px;
                    background: #a8edea;
                    color: #2d3748;
                    border-radius: 4px;
                    font-size: 12px;
                    font-weight: 500;
                    margin-right: 8px;
                  "
                >
                  {{ index + 1 }}
                </span>
                <strong style="color: #2d3748; font-size: 14px">
                  {{ result.title || 'æ— æ ‡é¢˜' }}
                </strong>
              </div>

              <div
                v-if="result.content"
                style="
                  margin: 8px 0;
                  color: #666;
                  font-size: 13px;
                  line-height: 1.5;
                  overflow: hidden;
                  text-overflow: ellipsis;
                  display: -webkit-box;
                  line-clamp: 5;
                  -webkit-line-clamp: 5;
                  -webkit-box-orient: vertical;
                "
              >
                {{ result.content.length > 300 ? result.content.slice(0, 300) +
                '...' : result.content }}
              </div>

              <div v-if="result.url" style="margin-top: 8px; line-height: 1.5">
                <a
                  :href="result.url"
                  target="_blank"
                  style="
                    color: #0066cc;
                    text-decoration: none;
                    font-size: 12px;
                    word-break: break-all;
                    display: -webkit-box;
                    line-clamp: 2;
                    -webkit-line-clamp: 2;
                    -webkit-box-orient: vertical;
                    overflow: hidden;
                    text-overflow: ellipsis;
                  "
                >
                  ğŸ”— {{ result.url }}
                </a>
              </div>
            </div>
          </div>

          <!-- æ— ç»“æœæç¤º -->
          <div
            v-else
            style="
              padding: 20px;
              text-align: center;
              color: #999;
              font-size: 14px;
            "
          >
            æš‚æ— æœç´¢ç»“æœ
          </div>
        </div>
      </div>

      <!-- éšè—çš„å…³äºé¡µé¢æ¨¡æ¿ -->
      <div ref="aboutTemplate" style="display: none">
        <div style="max-height: 70vh; overflow-y: auto; text-align: left">
          <div style="text-align: left; padding: 10px">
            <h3 style="margin: 0 0 10px; color: #333">âœ¨ åº”ç”¨ç®€ä»‹</h3>
            <p style="line-height: 1.6; color: #666">
              è¿™æ˜¯ä¸€ä¸ªç®€å•æ˜“ç”¨çš„ OpenAI API ä»£ç†æœåŠ¡ï¼ŒåŸºäº Deno Deploy /
              Cloudflare Workers éƒ¨ç½²ã€‚ åªéœ€è¦ä¸€ä¸ªåŸŸåå’Œ OpenAI API
              Keyï¼Œå³å¯å…è´¹ä¸ºå®¶äººæœ‹å‹æä¾› AI é—®ç­”æœåŠ¡ã€‚
            </p>

            <h3 style="margin: 20px 0 10px; color: #333">ğŸ¯ æ ¸å¿ƒåŠŸèƒ½</h3>
            <ul style="line-height: 1.8; color: #666; padding-left: 20px">
              <li>æä¾›æ ‡å‡†çš„ OpenAI API ä»£ç†ç«¯ç‚¹</li>
              <li>æ”¯æŒå¯†ç ä¿æŠ¤ï¼Œé¿å…æš´éœ² API Key</li>
              <li>å†…ç½®ç²¾ç¾çš„ Web èŠå¤©ç•Œé¢</li>
              <li>PWA é€‚é…ï¼Œæ”¯æŒç§»åŠ¨è®¾å¤‡æ·»åŠ åˆ°æ¡Œé¢</li>
              <li>æµå¼å“åº”ï¼Œå®æ—¶æ˜¾ç¤º AI å›ç­”</li>
              <li>åŸºäº IndexedDB æœ¬åœ°å†å²è®°å½•å­˜å‚¨</li>
              <li>æ”¯æŒæ¨¡å‹åˆ‡æ¢å’Œè‡ªå®šä¹‰ç³»ç»Ÿæç¤ºè¯</li>
              <li>é›†æˆ Tavily æœç´¢ï¼Œä¸º AI æä¾›å®æ—¶ç½‘ç»œä¿¡æ¯</li>
              <li>ä¸€é”®ç”Ÿæˆé—®ç­”æˆªå›¾ï¼Œæ–¹ä¾¿åˆ†äº«</li>
              <li>æ™ºèƒ½ä¼šè¯å‘½åï¼Œä¾¿äºæŸ¥æ‰¾ç®¡ç†</li>
            </ul>

            <h3 style="margin: 20px 0 10px; color: #333">ğŸ”— GitHub ä»“åº“</h3>
            <p style="line-height: 1.6; color: #666">
              <a
                href="https://github.com/icheer/openai-webui-lite"
                target="_blank"
                style="color: #0066cc; text-decoration: none"
              >
                https://github.com/icheer/openai-webui-lite
              </a>
            </p>

            <p style="margin: 20px 0 10px; color: #999; font-size: 0.9em">
              è¯·åˆç†ä½¿ç”¨ AI èµ„æºï¼Œé¿å…æ»¥ç”¨ï¼
            </p>
          </div>
        </div>
      </div>

      <!-- è®¾ç½®å¼¹çª—æ¨¡æ¿ -->
      <div
        v-if="!isShowSettingsModal"
        ref="settingsTemplate"
        style="display: none"
      >
        <div style="text-align: left; padding: 0 10px">
          <!-- API Key è®¾ç½® -->
          <div style="margin-bottom: 20px">
            <label
              class="label-api-key"
              style="
                display: block;
                margin-bottom: 8px;
                font-weight: 600;
                color: #333;
              "
            >
              ğŸ”‘ API Key
            </label>
            <input
              type="password"
              id="settingsApiKey"
              class="swal-input-custom"
              placeholder="è¯·è¾“å…¥æ‚¨çš„ OpenAI API Key"
              autocomplete="new-password"
              style="
                width: 100%;
                padding: 10px 12px;
                border: 1px solid #ddd;
                border-radius: 8px;
                font-size: 14px;
                box-sizing: border-box;
              "
            />
          </div>

          <!-- å­˜å‚¨æ¨¡å¼åˆ‡æ¢ -->
          <div style="margin-bottom: 20px">
            <label
              style="
                display: block;
                margin-bottom: 8px;
                font-weight: 600;
                color: #333;
              "
            >
              ğŸ’¾ ä¼šè¯å­˜å‚¨æ¨¡å¼
            </label>
            <div style="display: flex; gap: 12px">
              <label
                style="
                  display: flex;
                  align-items: center;
                  cursor: pointer;
                  padding: 10px 10px;
                  border: 2px solid #ddd;
                  border-radius: 8px;
                  flex: 1;
                  transition: all 0.2s;
                "
                class="storage-mode-option"
                data-mode="local"
              >
                <input
                  type="radio"
                  name="storageMode"
                  value="local"
                  style="margin-right: 8px"
                />
                <span style="font-size: 0.85em">
                  <span v-if="isMobile">ğŸ“±</span>
                  <span v-else>ğŸ–¥ï¸</span>
                  <span> æœ¬åœ°å­˜å‚¨</span>
                </span>
              </label>
              <label
                style="
                  display: flex;
                  align-items: center;
                  cursor: pointer;
                  padding: 10px 10px;
                  border: 2px solid #ddd;
                  border-radius: 8px;
                  flex: 1;
                  transition: all 0.2s;
                "
                class="storage-mode-option"
                data-mode="webdav"
              >
                <input
                  type="radio"
                  name="storageMode"
                  value="webdav"
                  style="margin-right: 8px"
                />
                <span style="font-size: 0.85em">â˜ï¸ è¿œç¨‹å­˜å‚¨</span>
              </label>
            </div>
            <p style="margin: 8px 0 0; font-size: 12px; color: #888">
              <span>æœ¬åœ°å­˜å‚¨ï¼šæ•°æ®ä¿å­˜åœ¨æµè§ˆå™¨ä¸­</span>
              <br v-if="isMobile" />
              <span v-else>ï¼›</span>
              <span>è¿œç¨‹å­˜å‚¨ï¼šé€šè¿‡ WebDAV åŒæ­¥åˆ°äº‘ç«¯</span>
            </p>
          </div>

          <!-- WebDAV é…ç½® -->
          <div
            id="webdavConfigSection"
            style="
              display: none;
              padding: 16px;
              background: #f8f9fa;
              border-radius: 8px;
              margin-bottom: 10px;
            "
          >
            <label
              style="
                display: block;
                margin-bottom: 12px;
                font-weight: 600;
                color: #333;
              "
            >
              WebDAV é…ç½®
            </label>
            <div style="margin-bottom: 12px">
              <label
                style="
                  display: block;
                  margin-bottom: 4px;
                  font-size: 13px;
                  color: #555;
                "
                >æœåŠ¡å™¨åœ°å€</label
              >
              <input
                type="text"
                id="webdavUrl"
                placeholder="http://dav.test.cn:3000"
                style="
                  width: 100%;
                  padding: 8px 12px;
                  border: 1px solid #ddd;
                  border-radius: 6px;
                  font-size: 14px;
                  box-sizing: border-box;
                "
              />
            </div>
            <div style="margin-bottom: 12px">
              <label
                style="
                  display: block;
                  margin-bottom: 4px;
                  font-size: 13px;
                  color: #555;
                "
                >ç”¨æˆ·å</label
              >
              <input
                type="text"
                id="webdavUsername"
                placeholder="ç”¨æˆ·å"
                style="
                  width: 100%;
                  padding: 8px 12px;
                  border: 1px solid #ddd;
                  border-radius: 6px;
                  font-size: 14px;
                  box-sizing: border-box;
                "
              />
            </div>
            <div style="margin-bottom: 12px">
              <label
                style="
                  display: block;
                  margin-bottom: 4px;
                  font-size: 13px;
                  color: #555;
                "
                >å¯†ç </label
              >
              <input
                type="password"
                id="webdavPassword"
                placeholder="å¯†ç "
                autocomplete="new-password"
                style="
                  width: 100%;
                  padding: 8px 12px;
                  border: 1px solid #ddd;
                  border-radius: 6px;
                  font-size: 14px;
                  box-sizing: border-box;
                "
              />
            </div>
            <div style="margin-bottom: 12px">
              <label
                style="
                  display: block;
                  margin-bottom: 4px;
                  font-size: 13px;
                  color: #555;
                "
                >å­˜å‚¨è·¯å¾„</label
              >
              <input
                type="text"
                id="webdavPath"
                placeholder="/openai-chat/"
                style="
                  width: 100%;
                  padding: 8px 12px;
                  border: 1px solid #ddd;
                  border-radius: 6px;
                  font-size: 14px;
                  box-sizing: border-box;
                "
              />
              <p style="margin: 4px 0 0; font-size: 11px; color: #888">
                åº”ä»¥'/'ç»“æŸï¼Œç•™ç©ºåˆ™ä½¿ç”¨é»˜è®¤è·¯å¾„ /openai-chat/
              </p>
            </div>
            <button
              type="button"
              id="testWebdavBtn"
              style="
                width: 100%;
                padding: 10px;
                background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
                border: none;
                border-radius: 6px;
                font-size: 14px;
                cursor: pointer;
                font-weight: 500;
              "
            >
              ğŸ”— æµ‹è¯•è¿æ¥
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const $ = selector => document.querySelector(selector);
      const $$ = selector => Array.from(document.querySelectorAll(selector));
      const { createApp } = Vue;

      window.app = createApp({
        data() {
          return {
            apiKey: '',
            messageInput: '',
            isLoading: false,
            isShowSettingsModal: false,
            isSentForAWhile: false,
            errorMessage: '',
            selectedModel: '',
            availableModels: ['$MODELS_PLACEHOLDER$'],
            sessions: [],
            currentSessionId: null,
            isFoldRole: false,
            isCapturing: false,
            globalRolePrompt: '',
            globalRolePromptEnabled: true,
            isMobile: window.innerWidth <= 768, // æ˜¯å¦ç§»åŠ¨è®¾å¤‡
            isWideMode: !!localStorage.getItem('wideMode'),
            showSidebar: false,
            isStreaming: false,
            streamingContent: '',
            abortController: null,
            uploadedImages: [], // å¾…å‘é€çš„å›¾ç‰‡åˆ—è¡¨ [{ url: string, file: File }]
            uploadedPlaintexts: [], // å¾…å‘é€çš„æ–‡æœ¬æ–‡ä»¶åˆ—è¡¨ [{ name: string, content: string }]
            isUploadingImage: false,
            needSearch: false,
            searchRes: null,
            tomSelect: null,
            sidebarHashAdded: false, // æ ‡è®°æ˜¯å¦ä¸ºä¾§è¾¹æ æ·»åŠ äº†hash
            swalHashAdded: false, // æ ‡è®°æ˜¯å¦ä¸ºå¼¹çª—æ·»åŠ äº†hash
            isLoadingRemoteSessions: false, // æ˜¯å¦æ­£åœ¨åŠ è½½è¿œç¨‹ä¼šè¯æ•°æ®
            // å­˜å‚¨æ¨¡å¼ç›¸å…³
            storageMode: 'local', // 'local' æˆ– 'webdav'
            webdavConfig: {
              url: '',
              username: '',
              password: '',
              path: '/openai-chat/'
            }
          };
        },
        computed: {
          isPC() {
            return !this.isMobile;
          },
          hostname() {
            return window.location.hostname;
          },
          isMySite() {
            return this.hostname.endsWith('.keyi.ma');
          },
          currentSession() {
            return this.sessions.find(s => s.id === this.currentSessionId);
          },
          isCurrentEnd() {
            var session = this.currentSession;
            if (!session) return false;
            if (this.isLoading || this.isStreaming) return false;
            // è·å–ç”¨æˆ·æ¶ˆæ¯æ•°é‡
            var userMsgCount = this.getUserMessageCount(session);
            // å¦‚æœç”¨æˆ·å·²å‘é€8æ¡æ¶ˆæ¯ï¼Œåˆ™ä¼šè¯ç»“æŸ
            if (userMsgCount >= 8) return true;
            // æˆ–è€…æœ€åä¸€æ¡æ¶ˆæ¯æ˜¯botçš„å›å¤ï¼Œç”¨æˆ·å¯ä»¥ç»§ç»­è¿½é—®
            return false;
          },
          // æ£€æŸ¥æ˜¯å¦å·²è¾¾åˆ°æœ€å¤§æ¶ˆæ¯æ•°é™åˆ¶
          isMaxMessagesReached() {
            var session = this.currentSession;
            if (!session) return false;
            return this.getUserMessageCount(session) >= 8;
          },
          // åˆ¤æ–­æ˜¯å¦æ­£åœ¨ä¸ºæ–°æ¶ˆæ¯ç”Ÿæˆå›å¤ï¼ˆæœ€åä¸€æ¡æ˜¯useræ¶ˆæ¯ä¸”æ­£åœ¨streamingï¼‰
          isStreamingNewAnswer() {
            if (!this.isLoading && !this.isStreaming) return false;
            var session = this.currentSession;
            if (!session || !session.messages || session.messages.length === 0)
              return false;
            var lastMsg = session.messages[session.messages.length - 1];
            return lastMsg.type === 'user';
          },
          isTotallyBlank() {
            const list = this.sessions || [];
            return !list.some(s => {
              return s.messages && s.messages.length > 0;
            });
          },
          inputPlaceholder() {
            var session = this.currentSession || {};
            var suffix = this.getRolePrompt() ? ' (role âœ“)' : '';
            if (!this.apiKey) {
              return 'è¯·å…ˆåœ¨å·¦ä¸Šè§’è®¾ç½® API Key';
            } else if (this.isLoadingRemoteSessions) {
              return 'æ­£åœ¨åŠ è½½è¿œç¨‹æ•°æ®...';
            } else if (this.isLoading) {
              return 'AI æ­£åœ¨æ€è€ƒä¸­...';
            } else if (this.isStreaming) {
              return 'AI æ­£åœ¨ç”Ÿæˆå›ç­”...';
            } else if (this.isUploadingImage) {
              return 'å›¾ç‰‡ä¸Šä¼ ä¸­...';
            } else if (this.isMaxMessagesReached) {
              return 'å½“å‰ä¼šè¯å·²è¾¾åˆ°æœ€å¤§æ¶ˆæ¯æ•°é™åˆ¶(8æ¡)';
            } else if (!this.selectedModel) {
              return 'è¯·é€‰æ‹©ä¸€ä¸ªæ¨¡å‹';
            } else if (session.messages && session.messages.length > 0) {
              return 'è¾“å…¥æ‚¨çš„è¿½é—®...' + suffix;
            } else {
              return 'è¾“å…¥æ‚¨çš„é—®é¢˜...' + suffix;
            }
          },
          canInput() {
            var session = this.currentSession;
            return (
              this.apiKey &&
              !this.isLoadingRemoteSessions &&
              !this.isLoading &&
              !this.isStreaming &&
              !this.isMaxMessagesReached
            );
          },
          canSend() {
            return (
              (this.messageInput.trim() ||
                this.uploadedImages.length > 0 ||
                this.uploadedPlaintexts.length > 0) &&
              this.selectedModel &&
              !this.isUploadingImage &&
              this.canInput
            );
          },
          canUploadImage() {
            const isModelSupport = /(gpt|qwen|kimi)/.test(this.selectedModel);
            return isModelSupport && this.isMySite;
          },
          // åˆ¤æ–­æ˜¯å¦éœ€è¦æ˜¾ç¤ºloading
          shouldShowLoading() {
            if (this.isLoading) return true;
            if (this.isStreaming) {
              if (!this.streamingContent) return true;
              if (this.streamingContent.endsWith(' æ¡ç›¸å…³ä¿¡æ¯ã€‚\n\n'))
                return true;
            }
            return false;
          },
          // åˆ¤æ–­æ˜¯å¦éœ€è¦æ˜¾ç¤º"é‡æ–°å›ç­”"æŒ‰é’®ï¼ˆæœ‰é—®é¢˜ä½†æ²¡æœ‰å›ç­”ï¼Œä¸”æ²¡æœ‰æ­£åœ¨åŠ è½½ï¼‰
          shouldShowRetryButton() {
            var session = this.currentSession;
            if (!session) return false;
            if (this.isLoading || this.isStreaming) return false;
            if (!session.messages || session.messages.length === 0)
              return false;
            // æœ€åä¸€æ¡æ¶ˆæ¯æ˜¯userç±»å‹ä¸”æ²¡æœ‰å¯¹åº”çš„botå›å¤
            var lastMsg = session.messages[session.messages.length - 1];
            return lastMsg.type === 'user';
          }
        },
        async mounted() {
          this.initModels();
          this.$nextTick(() => {
            this.initTomSelect();
          });

          // åŠ è½½WebDAVé…ç½®
          await window.openaiDB.loadWebDAVConfig();
          this.storageMode = window.openaiDB.webdavEnabled ? 'webdav' : 'local';
          this.webdavConfig = Object.assign({}, window.openaiDB.webdavConfig);

          // åˆå§‹åŒ– IndexedDB
          await window.openaiDB.init();

          const renderer = new marked.Renderer();
          const originalHtmlRenderer = renderer.html.bind(renderer);
          renderer.html = function (text) {
            // marked ä¼šè‡ªåŠ¨å¤„ç†ä»£ç å—å†…çš„å†…å®¹ï¼Œè¿™é‡Œåªå¤„ç†æ™®é€šæ–‡æœ¬
            // æœ‰æ¡ä»¶çš„è½¬ä¹‰ï¼šå¦‚æœ < åé¢ä¸æ˜¯ a, br, blockquote, details, summary æ ‡ç­¾ï¼Œæ‰è¿›è¡Œè½¬ä¹‰
            const escaped = text.replace(
              /<(?!\/?(a|br|blockquote|details|summary)[\s>])/gi,
              '&lt;'
            );
            return originalHtmlRenderer(escaped);
          };

          // é…ç½® marked
          marked.setOptions({
            renderer,
            breaks: true, // æ”¯æŒ GFM æ¢è¡Œ
            gfm: true, // å¯ç”¨ GitHub Flavored Markdown
            tables: true, // æ”¯æŒè¡¨æ ¼
            pedantic: false, // ä¸ä½¿ç”¨åŸå§‹çš„ markdown.pl è§„åˆ™
            sanitize: false, // ä¸æ¸…ç† HTMLï¼ˆå› ä¸ºæˆ‘ä»¬ä¿¡ä»»å†…å®¹ï¼‰
            smartLists: true, // ä½¿ç”¨æ›´æ™ºèƒ½çš„åˆ—è¡¨è¡Œä¸º
            smartypants: false // ä¸ä½¿ç”¨æ™ºèƒ½æ ‡ç‚¹ç¬¦å·
          });
          marked.use({
            extensions: [
              {
                name: 'strongWithCJK',
                level: 'inline',
                start(src) {
                  return src.match(/\*\*/)?.index;
                },
                tokenizer(src) {
                  const rule = /^\*\*([^\*]+?)\*\*/;
                  const match = rule.exec(src);
                  if (match) {
                    return {
                      type: 'strongWithCJK',
                      raw: match[0],
                      text: match[1]
                    };
                  }
                },
                renderer(token) {
                  return '<strong>' + token.text + '</strong>';
                }
              }
            ]
          });

          // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨ç«¯
          this.checkMobile();
          window.addEventListener('resize', this.checkMobile);

          // ç›‘å¬æµè§ˆå™¨åé€€äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯ä½“éªŒä¼˜åŒ–ï¼‰
          window.addEventListener('popstate', this.handlePopState);

          await this.loadData();
          if (this.sessions.length === 0) {
            this.createNewSession();
          }
          // è®¡ç®—OpenAI DBæ€»æ•°æ®é‡
          const totalDataSize = await window.openaiDB.getTotalDataSize();
          if (totalDataSize > 3) {
            this.showSwal({
              title: 'æ•°æ®é‡è¿‡å¤§',
              text:
                'å½“å‰å­˜å‚¨çš„æ•°æ®é‡ä¸º' +
                totalDataSize.toFixed(2) +
                ' MBï¼Œè¶…è¿‡äº† 3MBï¼Œå¯èƒ½ä¼šå½±å“æ€§èƒ½ã€‚å»ºè®®æ¸…ç†ä¸€äº›æ—§ä¼šè¯ã€‚',
              icon: 'warning',
              confirmButtonText: '&nbsp;çŸ¥é“äº†&nbsp;'
            });
          }
        },

        beforeUnmount() {
          window.removeEventListener('resize', this.checkMobile);
          window.removeEventListener('popstate', this.handlePopState);
        },
        watch: {
          messageInput() {
            this.autoResizeTextarea();
          },
          streamingContent() {
            this.stickToBottom();
          },
          selectedModel(newVal, oldVal) {
            // é¿å…åœ¨åˆå§‹åŒ–æ—¶è§¦å‘ä¿å­˜ï¼ˆç©ºå€¼å˜ä¸ºæœ‰æ•ˆå€¼æ—¶ä¸ä¿å­˜ï¼‰
            if (!oldVal && newVal) {
              // é¦–æ¬¡ä»ç©ºå€¼å˜ä¸ºæœ‰æ•ˆå€¼ï¼Œä¸è§¦å‘ä¿å­˜ï¼ˆç”± loadData è´Ÿè´£ï¼‰
              if (this.tomSelect && this.tomSelect.getValue() !== newVal) {
                this.tomSelect.setValue(newVal, true);
              }
              return;
            }
            // æ­£å¸¸çš„æ¨¡å‹åˆ‡æ¢ï¼Œæ›´æ–° TomSelect
            if (this.tomSelect && this.tomSelect.getValue() !== newVal) {
              this.tomSelect.setValue(newVal, true);
            }
          }
        },
        methods: {
          // ç§»åŠ¨ç«¯åé€€ä½“éªŒä¼˜åŒ–ï¼šæ·»åŠ hashé”šç‚¹
          addHash(type) {
            if (!this.isMobile) return;
            const hash = '#' + type;
            if (window.location.hash !== hash) {
              window.history.pushState(null, '', hash);
            }
          },

          // ç§»åŠ¨ç«¯åé€€ä½“éªŒä¼˜åŒ–ï¼šç§»é™¤hashé”šç‚¹
          removeHash() {
            if (!this.isMobile) return;
            if (window.location.hash) {
              window.history.back();
            }
          },

          // ç§»åŠ¨ç«¯åé€€ä½“éªŒä¼˜åŒ–ï¼šå¤„ç†æµè§ˆå™¨åé€€äº‹ä»¶
          handlePopState(event) {
            if (!this.isMobile) return;

            // å¦‚æœä¾§è¾¹æ æ˜¯æ‰“å¼€çš„ï¼Œå…³é—­å®ƒ
            if (this.showSidebar && this.sidebarHashAdded) {
              this.showSidebar = false;
              this.sidebarHashAdded = false;
              return;
            }

            // å¦‚æœæœ‰Swalå¼¹çª—æ‰“å¼€ï¼Œå…³é—­å®ƒ
            if (Swal.isVisible() && this.swalHashAdded) {
              Swal.close();
              this.swalHashAdded = false;
              return;
            }
          },

          // åŒ…è£…Swal.fireä»¥æ”¯æŒç§»åŠ¨ç«¯hashç®¡ç†
          showSwal(options, addHash = true) {
            const isMobile = this.isMobile;
            const originalDidOpen = options.didOpen;
            const originalWillClose = options.willClose;

            // æ‰©å±•didOpenå›è°ƒ
            options.didOpen = (...args) => {
              if (isMobile && addHash) {
                this.addHash('modal');
                this.swalHashAdded = true;
              }
              if (originalDidOpen) {
                originalDidOpen.apply(this, args);
              }
            };

            // æ‰©å±•willCloseå›è°ƒ
            options.willClose = (...args) => {
              if (isMobile && addHash && this.swalHashAdded) {
                this.removeHash();
                this.swalHashAdded = false;
              }
              if (originalWillClose) {
                originalWillClose.apply(this, args);
              }
            };

            return Swal.fire(options);
          },

          // åˆ‡æ¢PCå®½å±æ¨¡å¼
          toggleWideMode(flag = undefined) {
            this.isWideMode = !this.isWideMode;
            if (flag === true) {
              this.isWideMode = true;
            } else if (flag === false) {
              this.isWideMode = false;
            }
            if (this.isWideMode) {
              localStorage.setItem('wideMode', '1');
            } else {
              localStorage.removeItem('wideMode');
            }
          },

          // æ‰“å¼€è®¾ç½®å¼¹çª—
          openSettingsModal() {
            var template = this.$refs.settingsTemplate;
            if (!template) return;
            var htmlContent = template.innerHTML;

            Swal.fire({
              title: 'âš™ï¸ è®¾ç½®',
              html: htmlContent,
              width: this.isMobile ? '95%' : '500px',
              showCancelButton: true,
              confirmButtonText: 'ä¿å­˜',
              cancelButtonText: 'å–æ¶ˆ',
              confirmButtonColor: '#5fbdbd',
              allowOutsideClick: false,
              showCloseButton: false,
              reverseButtons: true,
              didOpen: async () => {
                this.isShowSettingsModal = true;
                await this.$nextTick();
                // å¡«å……å½“å‰å€¼
                var apiKeyInput = $('#settingsApiKey');
                if (apiKeyInput) apiKeyInput.value = this.apiKey || '';

                var localRadio = $('input[name="storageMode"][value="local"]');
                var webdavRadio = $(
                  'input[name="storageMode"][value="webdav"]'
                );
                if (this.storageMode === 'webdav' && webdavRadio) {
                  webdavRadio.checked = true;
                } else if (localRadio) {
                  localRadio.checked = true;
                }

                // å¡«å……WebDAVé…ç½®
                var urlInput = $('#webdavUrl');
                var usernameInput = $('#webdavUsername');
                var passwordInput = $('#webdavPassword');
                var pathInput = $('#webdavPath');
                if (urlInput) urlInput.value = this.webdavConfig.url || '';
                if (usernameInput)
                  usernameInput.value = this.webdavConfig.username || '';
                if (passwordInput)
                  passwordInput.value = this.webdavConfig.password || '';
                if (pathInput)
                  pathInput.value = this.webdavConfig.path || '/openai-chat/';

                // æ˜¾ç¤º/éšè—WebDAVé…ç½®åŒºåŸŸ
                var webdavSection = $('#webdavConfigSection');
                if (webdavSection) {
                  webdavSection.style.display =
                    this.storageMode === 'webdav' ? 'block' : 'none';
                }

                // æ›´æ–°é€‰ä¸­çŠ¶æ€æ ·å¼
                this.updateStorageModeStyle();

                // ç»‘å®šå­˜å‚¨æ¨¡å¼åˆ‡æ¢äº‹ä»¶
                var radios = $$('input[name="storageMode"]');
                radios.forEach(radio => {
                  radio.addEventListener('change', () => {
                    var webdavSection = $('#webdavConfigSection');
                    if (webdavSection) {
                      webdavSection.style.display =
                        radio.value === 'webdav' ? 'block' : 'none';
                    }
                    this.updateStorageModeStyle();
                  });
                });

                // ç»‘å®šæµ‹è¯•æŒ‰é’®äº‹ä»¶
                var testBtn = $('#testWebdavBtn');
                if (testBtn) {
                  testBtn.addEventListener('click', () => {
                    this.testWebDAVFromModal();
                  });
                }

                var title = $('.swal2-modal .swal2-title');
                if (title) {
                  title.addEventListener('dblclick', () => {
                    this.reloadPage();
                  });
                }
              },
              preConfirm: async () => {
                const isValid = await this.validateAndSaveSettings();
                if (isValid) {
                  this.isShowSettingsModal = false;
                }
                return isValid;
              }
            }).then(() => {
              this.isShowSettingsModal = false;
            });
          },

          // æ›´æ–°å­˜å‚¨æ¨¡å¼é€‰é¡¹æ ·å¼
          updateStorageModeStyle() {
            var options = $$('.storage-mode-option');
            options.forEach(option => {
              var radio = option.querySelector('input[type="radio"]');
              if (radio && radio.checked) {
                option.style.borderColor = '#5fbdbd';
                option.style.background = 'rgba(95, 189, 189, 0.1)';
              } else {
                option.style.borderColor = '#ddd';
                option.style.background = 'transparent';
              }
            });
          },

          // ä»å¼¹çª—ä¸­æµ‹è¯•WebDAVè¿æ¥
          async testWebDAVFromModal() {
            var urlInput = $('#webdavUrl');
            var usernameInput = $('#webdavUsername');
            var passwordInput = $('#webdavPassword');
            var pathInput = $('#webdavPath');
            var testBtn = $('#testWebdavBtn');
            var config = {
              url: urlInput ? urlInput.value.trim() : '',
              username: usernameInput ? usernameInput.value.trim() : '',
              password: passwordInput ? passwordInput.value : '',
              path: (pathInput ? pathInput.value.trim() : '') || '/openai-chat/'
            };

            // åŸºæœ¬éªŒè¯
            if (!config.url) {
              this.showToast('è¯·è¾“å…¥æœåŠ¡å™¨åœ°å€', 'error');
              return;
            }
            if (!config.username) {
              this.showToast('è¯·è¾“å…¥ç”¨æˆ·å', 'error');
              return;
            }
            if (!config.password) {
              this.showToast('è¯·è¾“å…¥å¯†ç ', 'error');
              return;
            }

            // æ˜¾ç¤ºæµ‹è¯•ä¸­çŠ¶æ€
            if (testBtn) {
              testBtn.disabled = true;
              testBtn.textContent = 'â³ æµ‹è¯•ä¸­...';
            }

            var result = await window.openaiDB.testWebDAVConnection(config);

            if (testBtn) {
              testBtn.disabled = false;
              testBtn.textContent = 'ğŸ”— æµ‹è¯•è¿æ¥';
            }

            if (result.success) {
              this.showToast('è¿æ¥æˆåŠŸï¼', 'success');
            } else {
              this.showToast('è¿æ¥å¤±è´¥: ' + result.error, 'error');
            }
          },

          // æ˜¾ç¤ºToastæç¤ºï¼ˆä¸å½±å“Swalå¼¹çª—ï¼‰
          showToast(message, icon) {
            // åˆ›å»ºtoastå®¹å™¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            var container = $('#custom-toast-container');
            if (!container) {
              container = document.createElement('div');
              container.id = 'custom-toast-container';
              container.style.cssText =
                'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 99999; display: flex; flex-direction: column; align-items: center; gap: 10px; pointer-events: none;';
              document.body.appendChild(container);
            }

            // åˆ›å»ºtoastå…ƒç´ 
            var toast = document.createElement('div');
            toast.style.cssText =
              'padding: 12px 20px; border-radius: 8px; background: #fff; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: flex; align-items: center; gap: 8px; font-size: 14px; opacity: 0; transform: translateY(-10px); transition: all 0.3s ease; pointer-events: auto;';

            // æ ¹æ®iconç±»å‹è®¾ç½®é¢œè‰²å’Œå›¾æ ‡
            var iconEmoji = 'ğŸ’¬';
            var bgColor = '#fff';
            var borderColor = '#e0e0e0';
            if (icon === 'success') {
              iconEmoji = 'âœ…';
              borderColor = '#5fbdbd';
            } else if (icon === 'error') {
              iconEmoji = 'âŒ';
              borderColor = '#e74c3c';
            } else if (icon === 'warning') {
              iconEmoji = 'âš ï¸';
              borderColor = '#f39c12';
            } else if (icon === 'info') {
              iconEmoji = 'â„¹ï¸';
              borderColor = '#3498db';
            }
            toast.style.borderLeft = '4px solid ' + borderColor;

            toast.innerHTML =
              '<span style="font-size: 16px;">' +
              iconEmoji +
              '</span><span>' +
              message +
              '</span>';
            container.appendChild(toast);

            // æ˜¾ç¤ºåŠ¨ç”»
            requestAnimationFrame(() => {
              toast.style.opacity = '1';
              toast.style.transform = 'translateY(0)';
            });

            // 3ç§’åéšè—å¹¶ç§»é™¤
            this.sleep(3000).then(() => {
              toast.style.opacity = '0';
              toast.style.transform = 'translateY(-10px)';
              this.sleep(300).then(() => {
                if (toast.parentNode) {
                  toast.parentNode.removeChild(toast);
                }
              });
            });
          },

          // éªŒè¯å¹¶ä¿å­˜è®¾ç½®
          async validateAndSaveSettings() {
            var apiKeyInput = $('#settingsApiKey');
            var apiKey = apiKeyInput ? apiKeyInput.value.trim() : '';

            var storageModeRadio = $('input[name="storageMode"]:checked');
            var storageMode = storageModeRadio
              ? storageModeRadio.value
              : 'local';

            // API Key éªŒè¯
            if (!apiKey) {
              this.showToast('è¯·è¾“å…¥ API Key', 'error');
              return false;
            }

            // åœ¨ä¿å­˜å‰è®°å½•æ—§çš„å­˜å‚¨æ¨¡å¼ï¼Œç”¨äºåç»­åˆ¤æ–­æ˜¯å¦åˆ‡æ¢äº†æ¨¡å¼
            var oldMode = window.openaiDB.webdavEnabled ? 'webdav' : 'local';

            // å¦‚æœé€‰æ‹©äº†WebDAVï¼ŒéªŒè¯é…ç½®
            if (storageMode === 'webdav') {
              var urlInput = $('#webdavUrl');
              var usernameInput = $('#webdavUsername');
              var passwordInput = $('#webdavPassword');
              var pathInput = $('#webdavPath');

              var webdavConfig = {
                url: urlInput ? urlInput.value.trim() : '',
                username: usernameInput ? usernameInput.value.trim() : '',
                password: passwordInput ? passwordInput.value : '',
                path:
                  (pathInput ? pathInput.value.trim() : '') || '/openai-chat/'
              };

              // WebDAVå¿…å¡«é¡¹éªŒè¯
              if (!webdavConfig.url) {
                this.showToast('è¯·è¾“å…¥ WebDAV æœåŠ¡å™¨åœ°å€', 'error');
                return false;
              }
              if (!webdavConfig.username) {
                this.showToast('è¯·è¾“å…¥ WebDAV ç”¨æˆ·å', 'error');
                return false;
              }
              if (!webdavConfig.password) {
                this.showToast('è¯·è¾“å…¥ WebDAV å¯†ç ', 'error');
                return false;
              }

              // WebDAVè¿é€šæ€§æµ‹è¯•
              Swal.showLoading();
              var result =
                await window.openaiDB.testWebDAVConnection(webdavConfig);
              if (!result.success) {
                Swal.hideLoading();
                this.showToast('WebDAV è¿æ¥å¤±è´¥: ' + result.error, 'error');
                return false;
              }

              // ä¿å­˜WebDAVé…ç½®
              this.webdavConfig = webdavConfig;
              await window.openaiDB.saveWebDAVConfig(true, webdavConfig);
              this.storageMode = 'webdav';
            } else {
              // æœ¬åœ°å­˜å‚¨æ¨¡å¼
              await window.openaiDB.saveWebDAVConfig(false, this.webdavConfig);
              this.storageMode = 'local';
            }

            // ä¿å­˜API Key
            this.apiKey = apiKey;
            await this.saveApiKey();

            // å¦‚æœåˆ‡æ¢äº†å­˜å‚¨æ¨¡å¼ï¼Œéœ€è¦é‡æ–°åŠ è½½æ•°æ®
            if (oldMode !== storageMode) {
              // é‡æ–°åŠ è½½ä¼šè¯æ•°æ®
              this.showToast('å­˜å‚¨æ¨¡å¼å·²åˆ‡æ¢ï¼Œæ­£åœ¨é‡æ–°åŠ è½½æ•°æ®...', 'info');
              await this.loadSessions();
            }

            this.showToast('è®¾ç½®å·²ä¿å­˜', 'success');
            return true;
          },

          // åŠ è½½ä¼šè¯æ•°æ®ï¼ˆç‹¬ç«‹æ–¹æ³•ï¼‰
          async loadSessions() {
            var savedSessions =
              await window.openaiDB.getItem('openai_sessions');
            if (savedSessions) {
              var parsed = JSON.parse(savedSessions);
              var migratedSessions = this.migrateSessionData(parsed);
              if (migratedSessions) {
                this.sessions = migratedSessions;
              } else {
                this.sessions = parsed;
              }
            } else {
              this.sessions = [];
            }

            // åŠ è½½å½“å‰ä¼šè¯ID
            var savedCurrentId = await window.openaiDB.getItem(
              'openai_current_session'
            );
            if (
              savedCurrentId &&
              this.sessions.find(s => s.id === savedCurrentId)
            ) {
              this.currentSessionId = savedCurrentId;
            } else if (this.sessions.length > 0) {
              this.currentSessionId = this.sessions[0].id;
            } else {
              this.createNewSession();
            }
          },

          initTomSelect() {
            if (this.tomSelect) return;
            if (this.availableModels.length <= 10) return;
            const el = $('#selectedModel');
            if (!el) return;
            const config = {
              plugins: ['dropdown_input'],
              valueField: 'value',
              labelField: 'label',
              searchField: ['label', 'value'],
              options: this.availableModels,
              items: [this.selectedModel],
              create: false,
              maxOptions: 100,
              maxItems: 1,
              render: {
                option: (data, escape) => {
                  return (
                    '<div>' +
                    '<span class="title">' +
                    escape(data.label) +
                    '</span>' +
                    '</div>'
                  );
                },
                item: (data, escape) => {
                  return '<div>' + escape(data.label) + '</div>';
                },
                no_results: (data, escape) => {
                  return '<div class="no-results" style="padding: 0.75em; text-align: center; color: #999;">æŸ¥æ— æ­¤é¡¹</div>';
                }
              },
              onChange: value => {
                this.selectedModel = value;
                this.saveData();
              },
              onDelete: () => false,
              onInitialize: () => {
                const input = $('.dropdown-input-wrap input');
                if (!input) return;
                input.style.paddingLeft = '12px';
                input.style.paddingRight = '12px';
                input.setAttribute('placeholder', 'æ¨¡å‹å…³é”®è¯');
              }
            };
            const tomSelect = new TomSelect(el, config);
            this.tomSelect = tomSelect;
            document.body.ontouchmove = e => {
              const isInDropdown = e.target.closest('.ts-dropdown');
              const isDropdownOpen = tomSelect.isOpen;
              if (isDropdownOpen && !isInDropdown) {
                tomSelect.close();
              }
            };
          },
          initModels() {
            const firstItem = this.availableModels[0];
            if (typeof firstItem === 'string') {
              this.availableModels = firstItem
                .trim()
                .split(',')
                .map(id => id.trim())
                .filter(id => id)
                .map(id => {
                  if (id.includes('=')) {
                    const [value, label] = id.split('=').map(s => s.trim());
                    return { value, label };
                  }
                  const parts = id.split('-');
                  parts.forEach((part, index) => {
                    if (part.includes('/')) {
                      const idx = part.indexOf('/');
                      part =
                        part.slice(0, idx + 1) +
                        (part.charAt(idx + 1) || '').toUpperCase() +
                        part.slice(idx + 2);
                    }
                    parts[index] = part.charAt(0).toUpperCase() + part.slice(1);
                  });
                  let label = parts.join(' ');
                  label = label
                    .replace(' Vl ', ' VL ')
                    .replace('Deepseek', 'DeepSeek')
                    .replace('Maxthinking', 'MaxThinking')
                    .replace('Glm', 'GLM')
                    .replace('Gpt', 'GPT')
                    .replace(' Cc', ' CC')
                    .replace('Or/', 'OR/')
                    .replace('Cs/', 'CS/')
                    .replace('Iflow/', 'iFlow/')
                    .replace('Gcli', 'gCLI')
                    .replace('Cpa/', 'CPA/')
                    .replace('B4u/', 'B4U/')
                    .replace('Kfc/', 'KFC/')
                    .replace('/', ' / ');
                  return {
                    value: id,
                    label: label
                  };
                });
            }
          },
          reloadPage() {
            location.reload();
          },
          // å¤‡ç”¨çš„èŠ±æ‹¬å·è§£ææ–¹æ³•ï¼Œç”¨äºå¤„ç†ç‰¹æ®Šæƒ…å†µ
          parseWithBraceMethod(inputBuffer) {
            let buffer = inputBuffer;
            let braceCount = 0;
            let startIndex = -1;
            let processed = false;

            for (let i = 0; i < buffer.length; i++) {
              if (buffer[i] === '{') {
                if (braceCount === 0) {
                  startIndex = i;
                }
                braceCount++;
              } else if (buffer[i] === '}') {
                braceCount--;
                if (braceCount === 0 && startIndex !== -1) {
                  // æ‰¾åˆ°å®Œæ•´çš„JSONå¯¹è±¡
                  const jsonStr = buffer.substring(startIndex, i + 1);

                  try {
                    const data = JSON.parse(jsonStr);

                    if (
                      data.candidates &&
                      data.candidates[0] &&
                      data.candidates[0].content
                    ) {
                      const content = data.candidates[0].content;
                      const delta =
                        (content &&
                          content.parts[0] &&
                          content.parts[0].text) ||
                        '';
                      if (delta) {
                        const shouldScroll = !this.streamingContent;
                        this.streamingContent += delta;
                        if (shouldScroll) {
                          this.scrollToBottom();
                        }
                      }
                      processed = true;
                    }
                  } catch (parseError) {
                    console.warn(
                      'èŠ±æ‹¬å·è§£ææ–¹æ³•ä¹Ÿå¤±è´¥:',
                      parseError,
                      'JSON:',
                      jsonStr
                    );
                  }

                  // ç§»é™¤å·²å¤„ç†çš„éƒ¨åˆ†
                  buffer = buffer.substring(i + 1);
                  i = -1; // é‡ç½®å¾ªç¯
                  startIndex = -1;
                  braceCount = 0;
                }
              }
            }

            return { buffer, processed };
          },

          sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
          },

          // æ•°æ®è¿ç§»ï¼šå°†æ—§æ ¼å¼(question/answer/question2/answer2)è½¬æ¢ä¸ºæ–°çš„messagesæ•°ç»„æ ¼å¼
          migrateSessionData(sessions) {
            if (!sessions || !Array.isArray(sessions)) return sessions;
            let migrated = false;
            sessions.forEach(session => {
              // å¦‚æœå·²ç»æœ‰messagesæ•°ç»„ï¼Œè·³è¿‡
              if (session.messages && Array.isArray(session.messages)) return;
              // åˆå§‹åŒ–messagesæ•°ç»„
              session.messages = [];
              // è¿ç§»ç¬¬ä¸€è½®é—®ç­”
              if (session.question) {
                session.messages.push({
                  type: 'user',
                  content: session.question,
                  images: session.images || [],
                  time: session.createdAt || '',
                  model: session.model || ''
                });
                migrated = true;
              }
              if (session.answer) {
                session.messages.push({
                  type: 'bot',
                  content: session.answer,
                  time: session.createdAt || '',
                  model: session.model || ''
                });
                migrated = true;
              }
              // è¿ç§»ç¬¬äºŒè½®é—®ç­”
              if (session.question2) {
                session.messages.push({
                  type: 'user',
                  content: session.question2,
                  images: session.images2 || [],
                  time: session.createdAt2 || '',
                  model: session.model2 || ''
                });
                migrated = true;
              }
              if (session.answer2) {
                session.messages.push({
                  type: 'bot',
                  content: session.answer2,
                  time: session.createdAt2 || '',
                  model: session.model2 || ''
                });
                migrated = true;
              }
              // åˆ é™¤æ—§å±æ€§
              delete session.question;
              delete session.answer;
              delete session.question2;
              delete session.answer2;
              delete session.images;
              delete session.images2;
              delete session.createdAt;
              delete session.createdAt2;
              delete session.model;
              delete session.model2;
            });
            if (migrated) {
              console.log(
                '[Migration] Sessions migrated to new messages format'
              );
              return sessions;
            } else {
              return false;
            }
          },

          async loadData() {
            // åŠ è½½ API Key
            this.apiKey =
              (await window.openaiDB.getItem('openai_api_key')) || '';

            // åŠ è½½å…¨å±€è§’è‰²è®¾å®š
            this.globalRolePrompt =
              (await window.openaiDB.getItem('openai_global_role_prompt')) ||
              '';
            this.globalRolePromptEnabled =
              (await window.openaiDB.getItem(
                'openai_global_role_prompt_enabled'
              )) !== false;

            // åŠ è½½å½“å‰ä¼šè¯ID
            const savedCurrentId = await window.openaiDB.getItem(
              'openai_current_session'
            );

            // åŠ è½½é€‰ä¸­çš„æ¨¡å‹
            const savedModel = await window.openaiDB.getItem(
              'openai_selected_model'
            );
            // éªŒè¯ savedModel æ˜¯å¦åœ¨å¯ç”¨æ¨¡å‹åˆ—è¡¨ä¸­
            let modelToUse = '';
            // ä¼˜å…ˆçº§1: ä½¿ç”¨ä¿å­˜çš„æ¨¡å‹ï¼ˆå¦‚æœåœ¨åˆ—è¡¨ä¸­ï¼‰
            if (
              savedModel &&
              this.availableModels.length > 0 &&
              this.availableModels.some(m => m.value === savedModel)
            ) {
              modelToUse = savedModel;
            }
            // ä¼˜å…ˆçº§2: å¦‚æœæ²¡æœ‰ä¿å­˜çš„æ¨¡å‹æˆ–ä¸åœ¨åˆ—è¡¨ä¸­ï¼Œä½¿ç”¨åˆ—è¡¨ç¬¬ä¸€ä¸ª
            else if (
              this.availableModels.length > 0 &&
              this.availableModels[0] &&
              this.availableModels[0].value
            ) {
              modelToUse = this.availableModels[0].value;
            }
            // ä¼˜å…ˆçº§3: å®Œå…¨æ²¡åŠæ³•ï¼Œä½¿ç”¨ç¡¬ç¼–ç å…œåº•ï¼ˆä½†è®°å½•è­¦å‘Šï¼‰
            else {
              console.warn('[Model] æ¨¡å‹åˆ—è¡¨æœªæ­£ç¡®åˆå§‹åŒ–ï¼Œä½¿ç”¨å…œåº•å€¼');
              modelToUse = 'gpt-4o-mini';
            }
            this.selectedModel = modelToUse;

            // åŠ è½½è”ç½‘æœç´¢å¼€å…³çŠ¶æ€
            this.needSearch = !!(await window.openaiDB.getItem(
              'openai_enable_search'
            ));

            // åŠ è½½ä¼šè¯æ•°æ®
            const savedSessions =
              await window.openaiDB.getItem('openai_sessions');
            if (savedSessions) {
              let parsed = JSON.parse(savedSessions);
              // æ‰§è¡Œæ•°æ®è¿ç§»
              const migratedSessions = this.migrateSessionData(parsed);
              if (migratedSessions) {
                this.sessions = migratedSessions;
                // è¿ç§»åä¿å­˜
                this.sleep(300).then(() => {
                  this.saveData();
                });
              } else {
                this.sessions = parsed;
              }
            }

            // è®¾ç½®å½“å‰ä¼šè¯ID
            if (
              savedCurrentId &&
              this.sessions.find(s => s.id === savedCurrentId)
            ) {
              this.currentSessionId = savedCurrentId;
            } else if (this.sessions.length > 0) {
              this.currentSessionId = this.sessions[0].id;
            }
            this.autoFoldRolePrompt();
            this.loadDraftFromCurrentSession(); // åŠ è½½å½“å‰ä¼šè¯çš„è‰ç¨¿

            // é¦–æ¬¡å‘ç”¨æˆ·è¯¢é—® API Key
            if (!this.apiKey && this.isTotallyBlank) {
              this.askApiKeyIfNeeded();
            }
          },

          async saveData() {
            await window.openaiDB.setItem(
              'openai_sessions',
              JSON.stringify(this.sessions)
            );
            await window.openaiDB.setItem(
              'openai_current_session',
              this.currentSessionId
            );
            await window.openaiDB.setItem(
              'openai_selected_model',
              this.selectedModel
            );
            await window.openaiDB.setItem(
              'openai_enable_search',
              this.needSearch
            );
          },

          async saveApiKey() {
            await window.openaiDB.setItem('openai_api_key', this.apiKey);
          },

          askApiKeyIfNeeded() {
            if (this.apiKey) return;
            this.showSwal({
              title: 'è¯·è¾“å…¥ API Key',
              input: 'password',
              inputPlaceholder: 'è¯·è¾“å…¥æ‚¨çš„ OpenAI API Key',
              showCancelButton: true,
              confirmButtonText: 'ä¿å­˜',
              cancelButtonText: 'å–æ¶ˆ',
              reverseButtons: true,
              preConfirm: value => {
                if (!value) {
                  Swal.showValidationMessage('API Key ä¸èƒ½ä¸ºç©º');
                  return false;
                }
                this.apiKey = value;
                this.saveApiKey();
              }
            });
          },

          createNewSession() {
            if (this.isLoading || this.isStreaming || this.isUploadingImage)
              return;
            // ä¿å­˜å½“å‰ä¼šè¯çš„è‰ç¨¿
            this.saveDraftToCurrentSession();
            const firstSession = this.sessions[0];
            // æ£€æŸ¥ç¬¬ä¸€ä¸ªä¼šè¯æ˜¯å¦ä¸ºç©ºï¼ˆæ²¡æœ‰æ¶ˆæ¯ï¼‰
            var isFirstEmpty =
              firstSession &&
              (!firstSession.messages || firstSession.messages.length === 0);
            if (isFirstEmpty) {
              this.currentSessionId = firstSession.id;
            } else {
              var newSession = {
                id: Date.now().toString(),
                title: 'æ–°ä¼šè¯',
                summary: '',
                role: '',
                draft: '',
                messages: [] // ä½¿ç”¨æ¶ˆæ¯æ•°ç»„ä»£æ›¿å›ºå®šå±æ€§
              };
              this.sessions.unshift(newSession);
              this.currentSessionId = newSession.id;
            }
            // åŠ è½½æ–°ä¼šè¯çš„è‰ç¨¿
            this.loadDraftFromCurrentSession();
            this.saveData();
            // ç§»åŠ¨ç«¯åˆ›å»ºæ–°ä¼šè¯åéšè—ä¾§è¾¹æ 
            if (this.isMobile) {
              this.hideSidebar();
            }
          },

          switchSession(sessionId) {
            if (this.isLoading || this.isStreaming || this.isUploadingImage)
              return;
            // ä¿å­˜å½“å‰ä¼šè¯çš„è‰ç¨¿
            this.saveDraftToCurrentSession();
            this.currentSessionId = sessionId;
            // åŠ è½½æ–°ä¼šè¯çš„è‰ç¨¿
            this.loadDraftFromCurrentSession();
            this.saveData();
            // ç§»åŠ¨ç«¯åˆ‡æ¢ä¼šè¯åéšè—ä¾§è¾¹æ 
            if (this.isMobile) {
              this.hideSidebar();
            }
            this.scrollToTop();
          },

          deleteSession(sessionId) {
            if (this.isLoading || this.isStreaming || this.isUploadingImage)
              return;
            const doDelete = () => {
              this.sessions = this.sessions.filter(s => s.id !== sessionId);
              if (this.currentSessionId === sessionId) {
                this.currentSessionId =
                  this.sessions.length > 0 ? this.sessions[0].id : null;
              }
              if (this.sessions.length === 0) {
                this.createNewSession();
              }
              this.loadDraftFromCurrentSession();
              this.saveData();
            };
            // å¦‚æœæ˜¯ç©ºä¼šè¯, ç›´æ¥åˆ é™¤
            const session = this.sessions.find(s => s.id === sessionId);
            if (!session) return;
            const isEmpty =
              (!session.messages || session.messages.length === 0) &&
              !session.draft;
            if (isEmpty) {
              doDelete();
              return;
            }
            this.showSwal(
              {
                title: 'ç¡®è®¤åˆ é™¤',
                text: 'æ‚¨ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä¼šè¯å—ï¼Ÿ',
                icon: 'warning',
                showCancelButton: true,
                confirmButtonColor: '#d33',
                confirmButtonText: 'åˆ é™¤',
                cancelButtonText: 'å–æ¶ˆ',
                reverseButtons: true
              },
              false
            ).then(result => {
              if (result.isConfirmed) {
                doDelete();
              }
            });
          },

          // è·å–ä¼šè¯ä¸­ç”¨æˆ·æ¶ˆæ¯çš„æ•°é‡
          getUserMessageCount(session) {
            if (!session || !session.messages) return 0;
            return session.messages.filter(m => m.type === 'user').length;
          },

          updateRolePrompt() {
            this.saveData();
          },

          async updateGlobalRolePrompt() {
            if (!this.globalRolePrompt && !this.globalRolePromptEnabled) {
              this.globalRolePromptEnabled = true;
              return;
            }
            await window.openaiDB.setItem(
              'openai_global_role_prompt',
              this.globalRolePrompt
            );
            await window.openaiDB.setItem(
              'openai_global_role_prompt_enabled',
              this.globalRolePromptEnabled
            );
          },

          getRolePrompt() {
            if (this.globalRolePromptEnabled) {
              return this.globalRolePrompt.trim();
            }
            return '';
          },

          clearRolePrompt() {
            this.globalRolePrompt = '';
            this.globalRolePromptEnabled = true;
            this.updateGlobalRolePrompt();
          },

          toggleRolePrompt() {
            this.globalRolePromptEnabled = !this.globalRolePromptEnabled;
            this.updateGlobalRolePrompt();
          },

          // è§¦å‘ä¸Šä¼ ï¼ˆå›¾ç‰‡æˆ–æ–‡æœ¬æ–‡ä»¶ï¼‰
          triggerUpload() {
            this.showSwal({
              title: 'é€‰æ‹©ä¸Šä¼ ç±»å‹',
              showCancelButton: true,
              showDenyButton: true,
              confirmButtonText: 'ğŸ“· å›¾ç‰‡',
              denyButtonText: 'ğŸ“„ æ–‡æœ¬æ–‡ä»¶',
              cancelButtonText: 'å–æ¶ˆ',
              confirmButtonColor: '#5fbdbd',
              denyButtonColor: '#9b8ed4',
              reverseButtons: false
            }).then(result => {
              if (result.isConfirmed) {
                this.triggerImageUpload();
              } else if (result.isDenied) {
                this.triggerPlaintextUpload();
              }
            });
          },

          // è§¦å‘å›¾ç‰‡ä¸Šä¼ 
          triggerImageUpload() {
            if (this.uploadedImages.length >= 5) {
              this.showSwal({
                title: 'æ— æ³•ä¸Šä¼ ',
                text: 'æœ€å¤šåªèƒ½ä¸Šä¼ 5å¼ å›¾ç‰‡',
                icon: 'warning',
                confirmButtonText: 'ç¡®å®š'
              });
              return;
            }
            this.preheatImageUploadService();
            this.$refs.imageInput.click();
          },

          // è§¦å‘æ–‡æœ¬æ–‡ä»¶ä¸Šä¼ 
          triggerPlaintextUpload() {
            if (this.uploadedPlaintexts.length >= 5) {
              this.showSwal({
                title: 'æ— æ³•ä¸Šä¼ ',
                text: 'æœ€å¤šåªèƒ½ä¸Šä¼ 5ä¸ªæ–‡æœ¬æ–‡ä»¶',
                icon: 'warning',
                confirmButtonText: 'ç¡®å®š'
              });
              return;
            }
            this.$refs.plaintextInput.click();
          },

          // è·å–æ”¯æŒçš„æ–‡æœ¬æ–‡ä»¶åç¼€åˆ—è¡¨
          getSupportedTextExtensions() {
            return [
              '.txt',
              '.md',
              '.markdown',
              '.html',
              '.htm',
              '.xml',
              '.json',
              '.js',
              '.jsx',
              '.ts',
              '.tsx',
              '.vue',
              '.svelte',
              '.css',
              '.scss',
              '.sass',
              '.less',
              '.styl',
              '.py',
              '.pyw',
              '.pyi',
              '.rb',
              '.php',
              '.java',
              '.kt',
              '.kts',
              '.c',
              '.cpp',
              '.cc',
              '.cxx',
              '.h',
              '.hpp',
              '.hxx',
              '.cs',
              '.go',
              '.rs',
              '.swift',
              '.m',
              '.mm',
              '.sh',
              '.bash',
              '.zsh',
              '.fish',
              '.ps1',
              '.bat',
              '.cmd',
              '.sql',
              '.graphql',
              '.gql',
              '.yaml',
              '.yml',
              '.toml',
              '.ini',
              '.conf',
              '.cfg',
              '.env',
              '.log',
              '.csv',
              '.tsv',
              '.tex',
              '.bib',
              '.rst',
              '.adoc',
              '.org',
              '.gitignore',
              '.dockerignore',
              '.editorconfig',
              '.eslintrc',
              '.prettierrc',
              '.babelrc',
              '.htaccess',
              '.nginx',
              '.conf',
              '.r',
              '.R',
              '.rmd',
              '.Rmd',
              '.lua',
              '.pl',
              '.pm',
              '.tcl',
              '.awk',
              '.sed',
              '.vim',
              '.vimrc',
              '.emacs',
              '.el',
              '.proto',
              '.thrift',
              '.avsc',
              '.tf',
              '.tfvars',
              '.hcl',
              '.gradle',
              '.properties',
              '.pom',
              '.cmake',
              '.make',
              '.makefile',
              '.mk',
              '.asm',
              '.s',
              '.nasm',
              '.patch',
              '.diff'
            ];
          },

          // å¤„ç†æ–‡æœ¬æ–‡ä»¶é€‰æ‹©
          async handlePlaintextSelect(event) {
            var file = event.target.files[0];
            if (!file) return;
            await this.processPlaintextFile(file);
            event.target.value = ''; // æ¸…ç©ºinput,å…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
          },

          // å¤„ç†æ–‡æœ¬æ–‡ä»¶ï¼ˆå…¬å…±é€»è¾‘ï¼‰
          async processPlaintextFile(file) {
            // æ£€æŸ¥æ–‡ä»¶æ•°é‡é™åˆ¶
            if (this.uploadedPlaintexts.length >= 5) {
              this.showSwal({
                title: 'æ— æ³•ä¸Šä¼ ',
                text: 'æœ€å¤šåªèƒ½ä¸Šä¼ 5ä¸ªæ–‡æœ¬æ–‡ä»¶',
                icon: 'warning',
                confirmButtonText: 'ç¡®å®š'
              });
              return;
            }

            // æ£€æŸ¥æ–‡ä»¶åç¼€
            var fileName = file.name || '';
            var ext =
              fileName.lastIndexOf('.') > -1
                ? fileName.substring(fileName.lastIndexOf('.')).toLowerCase()
                : '';
            var supportedExts = this.getSupportedTextExtensions();
            // å¦‚æœæœ‰åç¼€ä½†ä¸åœ¨æ”¯æŒåˆ—è¡¨ä¸­ï¼Œæç¤ºç”¨æˆ·
            if (ext && supportedExts.indexOf(ext) === -1) {
              this.showSwal({
                title: 'ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹',
                text: 'è¯·é€‰æ‹©æ–‡æœ¬æ–‡ä»¶ï¼Œå¦‚ .txt, .md, .js, .py ç­‰',
                icon: 'error',
                confirmButtonText: 'ç¡®å®š'
              });
              return;
            }

            // æ£€æŸ¥æ–‡ä»¶å¤§å° (é™åˆ¶1MB)
            if (file.size > 1 * 1024 * 1024) {
              this.showSwal({
                title: 'æ–‡ä»¶è¿‡å¤§',
                text: 'æ–‡æœ¬æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡1MB',
                icon: 'error',
                confirmButtonText: 'ç¡®å®š'
              });
              return;
            }

            // æ£€æŸ¥æ˜¯å¦å·²ç»ä¸Šä¼ è¿‡åŒåæ–‡ä»¶
            var isDuplicate = this.uploadedPlaintexts.some(
              item => item.name === fileName
            );
            if (isDuplicate) {
              this.showSwal({
                title: 'æ–‡ä»¶å·²å­˜åœ¨',
                text: 'å·²ç»ä¸Šä¼ è¿‡åŒåæ–‡ä»¶: ' + fileName,
                icon: 'warning',
                confirmButtonText: 'ç¡®å®š'
              });
              return;
            }

            // è¯»å–æ–‡ä»¶å†…å®¹
            try {
              var content = await this.readFileAsText(file);
              this.uploadedPlaintexts.push({
                name: fileName,
                content: content
              });
            } catch (error) {
              console.error('è¯»å–æ–‡ä»¶å¤±è´¥:', error);
              this.showSwal({
                title: 'è¯»å–å¤±è´¥',
                text: 'æ— æ³•è¯»å–æ–‡ä»¶å†…å®¹ï¼Œè¯·ç¡®ä¿æ˜¯æœ‰æ•ˆçš„æ–‡æœ¬æ–‡ä»¶',
                icon: 'error',
                confirmButtonText: 'ç¡®å®š'
              });
            }
          },

          // è¯»å–æ–‡ä»¶ä¸ºæ–‡æœ¬
          readFileAsText(file) {
            return new Promise((resolve, reject) => {
              var reader = new FileReader();
              reader.onload = () => {
                resolve(reader.result);
              };
              reader.onerror = () => {
                reject(reader.error);
              };
              reader.readAsText(file, 'UTF-8');
            });
          },

          // ç§»é™¤æ–‡æœ¬æ–‡ä»¶
          removePlaintext(index) {
            this.uploadedPlaintexts.splice(index, 1);
          },

          // æ¸…ç©ºä¸Šä¼ çš„æ–‡æœ¬æ–‡ä»¶
          clearUploadedPlaintexts() {
            this.uploadedPlaintexts = [];
          },

          // é¢„è§ˆæ–‡æœ¬æ–‡ä»¶å†…å®¹
          previewPlaintext(item) {
            var content = item.content || '';
            // æˆªå–å‰3000å­—ç¬¦é¢„è§ˆ
            var previewContent =
              content.length > 3000
                ? content.substring(0, 3000) + '\n\n... (å†…å®¹è¿‡é•¿ï¼Œå·²æˆªæ–­)'
                : content;
            this.showSwal({
              title: item.name,
              html:
                '<pre style="text-align: left; max-height: 60vh; overflow: auto; white-space: pre-wrap; word-wrap: break-word; background: #f5f5f5; padding: 12px; border-radius: 8px; font-size: 13px;">' +
                this.escapeHtml(previewContent) +
                '</pre>',
              width: this.isMobile ? '95%' : '700px',
              showConfirmButton: true,
              confirmButtonText: 'å…³é—­'
            });
          },

          // HTMLè½¬ä¹‰
          escapeHtml(text) {
            var div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
          },

          // æ„å»ºé™„ä»¶å†…å®¹å­—ç¬¦ä¸²
          buildAttachmentContent(plaintexts) {
            if (!plaintexts || plaintexts.length === 0) return '';
            var lines = [];
            lines.push(
              '\n\n---\n\n## é™„ä»¶\n\n**ä»¥ä¸‹æ˜¯ç”¨æˆ·æä¾›çš„é™„ä»¶å†…å®¹ï¼Œä»¥ \`<User_Attachment_æ•°å­—>\` åŒ…è£¹ï¼š**'
            );
            for (var i = 0; i < plaintexts.length; i++) {
              var item = plaintexts[i];
              var num = i + 1;
              lines.push('\n\n---\n\n### é™„ä»¶ ' + num + ':\n\n');
              lines.push(
                '<User_Attachment_' + num + ' filename="' + item.name + '">'
              );
              lines.push(item.content);
              lines.push('</User_Attachment_' + num + '>');
            }
            return lines.join('\n');
          },

          // é¢„å…ˆè°ƒç”¨ä¸Šä¼ å›¾ç‰‡æœåŠ¡çš„/healthæ¥å£,ä»¥å‡å°‘é¦–æ¬¡ä¸Šä¼ å»¶è¿Ÿ
          async preheatImageUploadService() {
            if (!this.isMySite) return;
            return fetch('https://pic.keyi.ma/health')
              .then(() => {})
              .catch(() => {});
          },

          // å¤„ç†ç²˜è´´äº‹ä»¶
          async handlePaste(event) {
            var clipboardData = event.clipboardData || window.clipboardData;
            if (!clipboardData) return;
            var items = clipboardData.items;
            if (!items || !items.length) return;

            // éå†å‰ªè´´æ¿é¡¹ç›®
            for (var i = 0; i < items.length; i++) {
              var item = items[i];

              // æ£€æŸ¥æ˜¯å¦ä¸ºå›¾ç‰‡ç±»å‹
              if (item.type.startsWith('image/')) {
                event.preventDefault(); // é˜»æ­¢é»˜è®¤ç²˜è´´è¡Œä¸º

                // æ£€æŸ¥æ˜¯å¦å·²è¾¾åˆ°ä¸Šä¼ é™åˆ¶
                if (this.uploadedImages.length >= 5) {
                  this.showSwal({
                    title: 'æ— æ³•ä¸Šä¼ ',
                    text: 'æœ€å¤šåªèƒ½ä¸Šä¼ 5å¼ å›¾ç‰‡',
                    icon: 'warning',
                    confirmButtonText: 'ç¡®å®š'
                  });
                  return;
                }

                // è·å–å›¾ç‰‡æ–‡ä»¶
                var file = item.getAsFile();
                if (!file) continue;

                // æ£€æŸ¥æ–‡ä»¶å¤§å° (é™åˆ¶10MB)
                if (file.size > 10 * 1024 * 1024) {
                  this.showSwal({
                    title: 'æ–‡ä»¶è¿‡å¤§',
                    text: 'å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡10MB',
                    icon: 'error',
                    confirmButtonText: 'ç¡®å®š'
                  });
                  return;
                }

                if (i === 0) {
                  await this.preheatImageUploadService();
                }
                // ä¸Šä¼ å›¾ç‰‡
                await this.uploadImageFile(file);
                return; // åªå¤„ç†ç¬¬ä¸€å¼ å›¾ç‰‡
              }

              // æ£€æŸ¥æ˜¯å¦ä¸ºæ–‡æœ¬æ–‡ä»¶ç±»å‹
              if (
                item.kind === 'file' &&
                (item.type.startsWith('text/') ||
                  item.type === 'application/json' ||
                  item.type === 'application/javascript' ||
                  item.type === 'application/xml' ||
                  item.type === '')
              ) {
                var textFile = item.getAsFile();
                if (!textFile) continue;

                // æ£€æŸ¥æ–‡ä»¶ååç¼€æ˜¯å¦æ”¯æŒ
                var fileName = textFile.name || '';
                var ext =
                  fileName.lastIndexOf('.') > -1
                    ? fileName
                        .substring(fileName.lastIndexOf('.'))
                        .toLowerCase()
                    : '';
                var supportedExts = this.getSupportedTextExtensions();

                // å¦‚æœæœ‰åç¼€ä¸”åœ¨æ”¯æŒåˆ—è¡¨ä¸­ï¼Œå¤„ç†æ–‡æœ¬æ–‡ä»¶
                if (ext && supportedExts.indexOf(ext) !== -1) {
                  event.preventDefault();
                  await this.processPlaintextFile(textFile);
                  return;
                }
              }
            }
          },

          // ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶ï¼ˆæå–å…¬å…±é€»è¾‘ï¼‰
          async uploadImageFile(file) {
            this.isUploadingImage = true;
            try {
              // å¦‚æœå½“å‰æ¨¡å‹æ”¯æŒå›¾ç‰‡ä¸Šä¼ ,åˆ™ä¸Šä¼ åˆ°å›¾åºŠ
              if (this.canUploadImage) {
                const formData = new FormData();
                formData.append('image', file);

                // åˆ›å»ºè¶…æ—¶ Promise
                const timeoutPromise = new Promise((_, reject) => {
                  setTimeout(
                    () => reject(new Error('ä¸Šä¼ è¶…æ—¶ï¼ˆ15ç§’ï¼‰')),
                    15000
                  );
                });

                // åˆ›å»ºä¸Šä¼ å›¾åºŠ Promise
                const uploadPromise = fetch('https://pic.keyi.ma/upload', {
                  method: 'POST',
                  body: formData
                });

                // ä½¿ç”¨ Promise.race å®ç°è¶…æ—¶æ§åˆ¶
                const response = await Promise.race([
                  uploadPromise,
                  timeoutPromise
                ]);

                if (!response.ok) {
                  throw new Error('ä¸Šä¼ å¤±è´¥: ' + response.statusText);
                }

                const data = await response.json();

                if (data.success && data.url) {
                  this.uploadedImages.push({
                    url: data.url,
                    file: file
                  });
                } else {
                  throw new Error('ä¸Šä¼ å¤±è´¥: è¿”å›æ•°æ®æ ¼å¼é”™è¯¯');
                }
              } else {
                // ä¸æ”¯æŒå›¾ç‰‡URLçš„æ¨¡å‹,åªä¿å­˜fileå¯¹è±¡,å‘é€æ—¶å†è½¬base64
                this.uploadedImages.push({
                  file: file
                });
              }
            } catch (error) {
              console.error('ä¸Šä¼ å›¾ç‰‡å¤±è´¥:', error);
              this.showSwal({
                title: 'ä¸Šä¼ å¤±è´¥',
                text: error.message,
                icon: 'error',
                confirmButtonText: 'ç¡®å®š'
              });
            } finally {
              this.isUploadingImage = false;
            }
          },

          // å¤„ç†å›¾ç‰‡é€‰æ‹©
          async handleImageSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // æ£€æŸ¥æ–‡ä»¶ç±»å‹
            if (!file.type.startsWith('image/')) {
              this.showSwal({
                title: 'æ–‡ä»¶ç±»å‹é”™è¯¯',
                text: 'è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶',
                icon: 'error',
                confirmButtonText: 'ç¡®å®š'
              });
              event.target.value = '';
              return;
            }

            // æ£€æŸ¥æ–‡ä»¶å¤§å° (é™åˆ¶10MB)
            if (file.size > 10 * 1024 * 1024) {
              this.showSwal({
                title: 'æ–‡ä»¶è¿‡å¤§',
                text: 'å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡10MB',
                icon: 'error',
                confirmButtonText: 'ç¡®å®š'
              });
              event.target.value = '';
              return;
            }

            // ä¸Šä¼ å›¾ç‰‡
            await this.uploadImageFile(file);
            event.target.value = ''; // æ¸…ç©ºinput,å…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
          },

          // ç§»é™¤å›¾ç‰‡
          removeImage(index) {
            this.uploadedImages.splice(index, 1);
          },

          // æ¸…ç©ºä¸Šä¼ çš„å›¾ç‰‡
          clearUploadedImages() {
            this.uploadedImages = [];
          },

          // é¢„è§ˆå›¾ç‰‡
          previewImage(imageUrl) {
            // å¦‚æœæ˜¯INVALIDæ ‡è®°,ä¸æ”¯æŒé¢„è§ˆ
            if (imageUrl === 'INVALID') return;
            this.showSwal({
              imageUrl: imageUrl,
              imageAlt: 'å›¾ç‰‡é¢„è§ˆ',
              showCloseButton: true,
              showConfirmButton: false,
              width: 'auto',
              customClass: {
                image: 'swal-image-preview'
              }
            });
          },

          // è·å–å›¾ç‰‡çš„æ˜¾ç¤ºURL(ç”¨äºæ ‡ç­¾æ˜¾ç¤º)
          getImageDisplayUrl(img) {
            if (img.url) {
              return img.url;
            } else if (img.file) {
              return URL.createObjectURL(img.file);
            }
            return '';
          },

          // å°†Fileå¯¹è±¡è½¬ä¸ºbase64
          fileToBase64(file) {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(file);
            });
          },

          formatTimeStr(time) {
            let str = new Date(time).toLocaleString();
            str = str.replace(/:\d{1,2}$/, '');
            return str;
          },

          checkMobile() {
            const isUaMobile = navigator.userAgent
              .toLowerCase()
              .includes('mobile');
            const isSizeMobile = window.innerWidth <= 768;
            this.isMobile = isUaMobile || isSizeMobile;
            if (this.isMobile) {
              document.body.className = 'mobile';
              this.toggleWideMode(false);
              return true;
            } else {
              document.body.className = 'pc';
              return false;
            }
          },

          toggleSidebar() {
            if (this.isLoading || this.isStreaming) return;
            this.showSidebar = !this.showSidebar;

            // ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šæ˜¾ç¤ºä¾§è¾¹æ æ—¶æ·»åŠ hashï¼Œéšè—æ—¶ç§»é™¤hash
            if (this.isMobile) {
              if (this.showSidebar) {
                this.addHash('sidebar');
                this.sidebarHashAdded = true;
              } else {
                if (this.sidebarHashAdded) {
                  this.removeHash();
                  this.sidebarHashAdded = false;
                }
              }
            }
          },

          hideSidebar() {
            this.showSidebar = false;
            // ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šéšè—ä¾§è¾¹æ æ—¶ç§»é™¤hash
            if (this.isMobile && this.sidebarHashAdded) {
              this.removeHash();
              this.sidebarHashAdded = false;
            }
          },

          cancelStreaming() {
            if (this.abortController) {
              this.abortController.abort();
              this.abortController = undefined;
            }
            this.isStreaming = false;
            this.isLoading = false;
            var session = this.currentSession;
            // å°†æµå¼å†…å®¹ä¿å­˜ä¸ºæœ€æ–°çš„ bot æ¶ˆæ¯
            if (this.streamingContent && session && session.messages) {
              session.messages.push({
                type: 'bot',
                content: this.streamingContent,
                time: new Date().toISOString(),
                model: this.selectedModel
              });
            }
            this.saveData();
            this.streamingContent = '';
          },

          renderMarkdown(text) {
            if (!text) return '';

            // ä½¿ç”¨ marked è§£æ Markdown
            let html = marked.parse(text);

            return html;
          },

          copyToClipboard(text) {
            const regexRel = /\[(\d+)\]\(javascript:void\(0\)\)/g;
            text = text.replace(regexRel, '$1');
            // å°† <details class="thinking" ... ç›´è‡³</detail>çš„å†…å®¹ç§»é™¤
            const regexThinking =
              /<details class="thinking"[\s\S]*?<\/details>/g;
            text = text.replace(regexThinking, '');
            text = text.trim();
            navigator.clipboard
              .writeText(text)
              .then(() => {
                this.showSwal({
                  title: 'å¤åˆ¶æˆåŠŸ',
                  text: 'å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿',
                  icon: 'success',
                  timer: 1500,
                  showConfirmButton: false
                });
              })
              .catch(() => {
                this.showSwal({
                  title: 'å¤åˆ¶å¤±è´¥',
                  text: 'è¯·æ‰‹åŠ¨å¤åˆ¶å†…å®¹',
                  icon: 'error',
                  confirmButtonText: 'ç¡®å®š'
                });
              });
          },

          answerClickHandler(e) {
            const target = e.target;
            if (target.tagName !== 'A') return;
            if (target.href === 'javascript:void(0)') {
              e.preventDefault();
            }
            const blockquote = target.closest('blockquote');
            const isClickingSearchRes =
              blockquote && blockquote.innerText.startsWith('è”ç½‘æœç´¢ï¼š');
            if (!isClickingSearchRes) return;
            const idx = Array.from(blockquote.querySelectorAll('a')).indexOf(
              target
            );
            const matches = blockquote.innerText.match(
              new RegExp('ã€Œ(.*?)ã€', 'g')
            );
            let query = matches && matches[idx];
            if (!query) return;
            query = query.replace(/ã€Œ|ã€/g, '').trim();
            this.showSearchRes(query);
          },

          // å±•ç¤ºæœç´¢ç»“æœ
          async showSearchRes(query) {
            const searchRes = this.getSearchRes(query);
            if (!searchRes) {
              this.searchRes = null;
              return;
            } else {
              this.searchRes = searchRes;
            }
            await this.$nextTick();
            const template = this.$refs.searchResTemplate;
            if (!template) return;
            const htmlContent = template.innerHTML;
            // æ˜¾ç¤ºå¼¹çª—
            this.showSwal({
              title: 'è”ç½‘æœç´¢è¯¦æƒ…',
              html: htmlContent,
              width: this.isMobile ? '95%' : '800px',
              showConfirmButton: true,
              confirmButtonText: '&nbsp;å…³é—­&nbsp;',
              showCancelButton: false,
              reverseButtons: true,
              customClass: {
                popup: 'search-results-popup',
                htmlContainer: 'search-results-content'
              }
            });
          },

          async shareSession() {
            const sessionContent = $('.session-content');
            if (!sessionContent) {
              this.showSwal({
                title: 'æˆªå›¾å¤±è´¥',
                text: 'æœªæ‰¾åˆ°è¦æˆªå›¾çš„å†…å®¹',
                icon: 'error',
                confirmButtonText: 'ç¡®å®š'
              });
              return;
            }
            this.isCapturing = true;
            await this.$nextTick();

            // æ˜¾ç¤ºåŠ è½½æç¤º
            this.showSwal({
              title: 'æ­£åœ¨ç”Ÿæˆæˆªå›¾...',
              allowOutsideClick: false,
              didOpen: () => {
                Swal.showLoading();
              }
            });

            // ä½¿ç”¨html2canvasæˆªå›¾
            html2canvas(sessionContent, {
              backgroundColor: '#ffffff',
              scale: window.devicePixelRatio || 1,
              useCORS: true,
              allowTaint: false,
              logging: false,
              height: null,
              width: null
            })
              .then(canvas => {
                // æ£€æµ‹æ˜¯å¦ä¸ºå¾®ä¿¡æµè§ˆå™¨ç¯å¢ƒ
                const userAgent = navigator.userAgent.toLowerCase();
                const isWechat =
                  userAgent.includes('micromessenger') &&
                  userAgent.includes('mobile');
                const isMobile = this.isMobile;
                const imageDataUrl = canvas.toDataURL('image/png');
                this.showSwal({
                  title: isMobile ? 'é•¿æŒ‰ä¿å­˜å›¾ç‰‡' : 'å³é”®å¤åˆ¶å›¾ç‰‡',
                  html:
                    '<div style="max-height: 70vh; overflow-y: auto;"><img src="' +
                    imageDataUrl +
                    '" style="max-width: 100%; height: auto; border-radius: 8px;" /></div>',
                  showConfirmButton: true,
                  confirmButtonText: '&nbsp;ä¸‹è½½&nbsp;',
                  showCancelButton: true,
                  cancelButtonText: '&nbsp;å…³é—­&nbsp;',
                  width: isMobile ? '95%' : 'auto',
                  padding: '0.25em 0 1em',
                  customClass: {
                    htmlContainer: 'swal-image-container'
                  }
                }).then(result => {
                  // å¦‚æœç‚¹å‡»äº†ç¡®è®¤æŒ‰é’®ï¼ˆæ˜¾ç¤ºä¸º"ä¸‹è½½"ï¼‰
                  if (result.isConfirmed) {
                    const link = document.createElement('a');
                    const regex = new RegExp('[\/\: ]', 'g');
                    link.download =
                      'openai-chat-' +
                      new Date().toLocaleString().replace(regex, '-') +
                      '.png';
                    link.href = imageDataUrl;

                    // è§¦å‘ä¸‹è½½
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    // æ˜¾ç¤ºä¸‹è½½æˆåŠŸæç¤º
                    this.showSwal({
                      title: 'ä¸‹è½½æˆåŠŸ',
                      text: 'å›¾ç‰‡å·²ä¿å­˜åˆ°ä¸‹è½½æ–‡ä»¶å¤¹',
                      icon: 'success',
                      timer: 2000,
                      showConfirmButton: false
                    });
                  }
                });
              })
              .catch(error => {
                console.error('æˆªå›¾å¤±è´¥:', error);
                this.showSwal({
                  title: 'æˆªå›¾å¤±è´¥',
                  text: 'ç”Ÿæˆå›¾ç‰‡æ—¶å‡ºç°é”™è¯¯: ' + error.message,
                  icon: 'error',
                  confirmButtonText: 'ç¡®å®š'
                });
              })
              .finally(() => {
                this.isCapturing = false;
              });
          },

          updateSessionTitle() {
            var session = this.currentSession;
            if (session && session.messages && session.messages.length > 0) {
              var firstUserMsg = session.messages.find(m => m.type === 'user');
              if (firstUserMsg && firstUserMsg.content) {
                var text = firstUserMsg.content;
                session.title =
                  text.slice(0, 30) + (text.length > 30 ? '...' : '');
              }
            }
          },

          getModelName(value) {
            const model = this.availableModels.find(i => i.value === value);
            if (model) {
              return model.label;
            } else {
              return value;
            }
          },

          // è·å–æ¶ˆæ¯æ ‡ç­¾ï¼ˆé—®é¢˜/è¿½é—®ï¼‰
          getMsgLabel(msg, msgIndex) {
            if (msg.type !== 'user') return 'å›ç­”';
            var session = this.currentSession;
            if (!session || !session.messages) return 'é—®é¢˜';
            // è®¡ç®—è¿™æ˜¯ç¬¬å‡ ä¸ªç”¨æˆ·æ¶ˆæ¯
            var userMsgIdx = 0;
            for (var i = 0; i <= msgIndex; i++) {
              if (session.messages[i].type === 'user') userMsgIdx++;
            }
            return userMsgIdx === 1 ? 'é—®é¢˜' : 'è¿½é—®';
          },

          // åˆ¤æ–­æ˜¯å¦å¯ä»¥ç¼–è¾‘è¯¥æ¶ˆæ¯
          canEditMessage(msgIndex) {
            if (this.isLoading || this.isStreaming) return false;
            var session = this.currentSession;
            if (!session || !session.messages) return false;
            var msg = session.messages[msgIndex];
            if (msg.type !== 'user') return false;
            // åªæœ‰æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯å¯ä»¥ç¼–è¾‘
            for (var i = msgIndex + 1; i < session.messages.length; i++) {
              if (session.messages[i].type === 'user') return false;
            }
            return true;
          },

          // åˆ¤æ–­æ˜¯å¦å¯ä»¥é‡æ–°ç”Ÿæˆè¯¥å›ç­”
          canRegenerateMessage(msgIndex) {
            if (this.isLoading || this.isStreaming) return false;
            var session = this.currentSession;
            if (!session || !session.messages) return false;
            var msg = session.messages[msgIndex];
            if (msg.type !== 'bot') return false;
            // åªæœ‰æœ€åä¸€æ¡botæ¶ˆæ¯å¯ä»¥é‡æ–°ç”Ÿæˆ
            return msgIndex === session.messages.length - 1;
          },

          // åˆ¤æ–­æ˜¯å¦æ˜¯æœ€åä¸€æ¡botæ¶ˆæ¯
          isLastBotMsg(msgIndex) {
            var session = this.currentSession;
            if (!session || !session.messages) return false;
            var msg = session.messages[msgIndex];
            if (msg.type !== 'bot') return false;
            // æ£€æŸ¥åé¢æ˜¯å¦è¿˜æœ‰botæ¶ˆæ¯
            for (var i = msgIndex + 1; i < session.messages.length; i++) {
              if (session.messages[i].type === 'bot') return false;
            }
            return true;
          },

          // åˆ¤æ–­æ˜¯å¦å¯ä»¥åˆ†å‰è¯¥æ¶ˆæ¯ï¼ˆåªæœ‰éæœ€æ–°çš„botæ¶ˆæ¯å¯ä»¥åˆ†å‰ï¼‰
          canForkMessage(msgIndex) {
            if (this.isLoading || this.isStreaming) return false;
            var session = this.currentSession;
            if (!session || !session.messages) return false;
            var msg = session.messages[msgIndex];
            if (msg.type !== 'bot') return false;
            // ä¸æ˜¯æœ€åä¸€æ¡botæ¶ˆæ¯æ‰å¯ä»¥åˆ†å‰
            return !this.isLastBotMsg(msgIndex);
          },

          // è·å–botæ¶ˆæ¯åº”è¯¥æ˜¾ç¤ºçš„å†…å®¹ï¼ˆå¤„ç†æµå¼å›ç­”çš„æ˜¾ç¤ºé€»è¾‘ï¼‰
          getBotMessageContent(msg, msgIndex) {
            // å¦‚æœæ˜¯æœ€åä¸€æ¡botæ¶ˆæ¯ ä¸” æ­£åœ¨åŠ è½½/æµå¼ä¼ è¾“ ä¸” ä¸æ˜¯ä¸ºæ–°æ¶ˆæ¯ç”Ÿæˆå›å¤
            // åˆ™æ˜¾ç¤ºæµå¼å†…å®¹ï¼Œå¦åˆ™æ˜¾ç¤ºåŸæ¶ˆæ¯å†…å®¹
            if (
              this.isLastBotMsg(msgIndex) &&
              (this.isLoading || this.isStreaming) &&
              !this.isStreamingNewAnswer
            ) {
              return this.streamingContent;
            }
            return msg.content;
          },

          async sendMessage() {
            if (
              (!this.messageInput.trim() &&
                this.uploadedImages.length === 0 &&
                this.uploadedPlaintexts.length === 0) ||
              !this.apiKey
            )
              return;
            if (this.isLoading || this.isStreaming || this.isUploadingImage)
              return;

            // å¦‚æœå·²è¾¾åˆ°æœ€å¤§æ¶ˆæ¯æ•°é™åˆ¶ï¼Œåˆ›å»ºæ–°ä¼šè¯
            if (this.isMaxMessagesReached) {
              this.createNewSession();
              return;
            }

            this.errorMessage = '';
            var userMessage = this.messageInput.trim();

            // å¤„ç†å›¾ç‰‡:å¦‚æœä¸æ”¯æŒURL,è½¬ä¸ºbase64;å¦åˆ™ä½¿ç”¨URL
            var userImages = [];
            var userImagesForSending = []; // ç”¨äºå‘é€APIçš„å›¾ç‰‡æ•°ç»„
            for (var imgI = 0; imgI < this.uploadedImages.length; imgI++) {
              var imgItem = this.uploadedImages[imgI];
              if (imgItem.url) {
                // æœ‰URL,ä½¿ç”¨URL
                userImages.push(imgItem.url);
                userImagesForSending.push(imgItem.url);
              } else if (imgItem.file) {
                // æ²¡æœ‰URL,éœ€è¦è½¬base64å‘é€,ä½†sessionä¸­ä¿å­˜INVALID
                userImages.push('INVALID');
                var base64 = await this.fileToBase64(imgItem.file);
                userImagesForSending.push(base64);
              }
            }

            // å¤„ç†æ–‡æœ¬é™„ä»¶
            var userPlaintexts = [];
            for (var txtI = 0; txtI < this.uploadedPlaintexts.length; txtI++) {
              userPlaintexts.push({
                name: this.uploadedPlaintexts[txtI].name,
                content: this.uploadedPlaintexts[txtI].content
              });
            }

            this.clearInput();
            this.clearUploadedImages(); // æ¸…ç©ºä¸Šä¼ çš„å›¾ç‰‡
            this.clearUploadedPlaintexts(); // æ¸…ç©ºä¸Šä¼ çš„æ–‡æœ¬æ–‡ä»¶
            // æ¸…ç©ºå½“å‰ä¼šè¯çš„è‰ç¨¿
            if (this.currentSession) {
              this.currentSession.draft = '';
            }

            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
            if (!this.currentSession) {
              this.createNewSession();
            }
            var session = this.currentSession;
            session.role = this.getRolePrompt();

            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°messagesæ•°ç»„
            var userMsgObj = {
              type: 'user',
              content: userMessage,
              images: userImages,
              plaintexts: userPlaintexts,
              time: new Date().toISOString(),
              model: this.selectedModel
            };
            session.messages.push(userMsgObj);

            // å¦‚æœæ˜¯ç¬¬ä¸€æ¡æ¶ˆæ¯ï¼Œè‡ªåŠ¨æŠ˜å è§’è‰²è®¾å®š
            if (session.messages.length === 1) {
              this.autoFoldRolePrompt();
            }

            this.updateSessionTitle();
            this.saveData();
            this.scrollToBottom();

            // å‘é€åˆ° OpenAI API (æµå¼)
            var apiMessages = [];
            this.isLoading = true;
            this.isStreaming = false;
            this.isSentForAWhile = false;
            this.sleep(2500).then(() => {
              this.isSentForAWhile = true;
            });
            this.streamingContent = '';
            this.abortController = new AbortController();

            // ç»„è£…messages - OpenAIæ ¼å¼
            if (this.getRolePrompt()) {
              var needAssistant = /claude|gpt5/i.test(this.selectedModel);
              apiMessages.push({
                role: !needAssistant ? 'system' : 'assistant',
                content: this.globalRolePrompt.trim()
              });
            }

            // éå†messagesæ•°ç»„æ„å»ºAPIæ¶ˆæ¯
            for (var idx = 0; idx < session.messages.length; idx++) {
              var msg = session.messages[idx];
              var isLastUserMsg =
                idx === session.messages.length - 1 && msg.type === 'user';

              if (msg.type === 'user') {
                var content = [];
                // æ„å»ºæ–‡æœ¬å†…å®¹ï¼ˆåŒ…å«é™„ä»¶ï¼‰
                var textContent = msg.content || '';
                var plaintextsToUse = isLastUserMsg
                  ? userPlaintexts
                  : msg.plaintexts || [];
                if (plaintextsToUse && plaintextsToUse.length > 0) {
                  textContent += this.buildAttachmentContent(plaintextsToUse);
                }
                // æ·»åŠ æ–‡æœ¬å†…å®¹
                if (textContent && textContent.trim()) {
                  content.push({
                    type: 'text',
                    text: textContent
                  });
                }
                // æ·»åŠ å›¾ç‰‡å†…å®¹
                var imagesToUse = isLastUserMsg
                  ? userImagesForSending
                  : msg.images || [];
                if (imagesToUse && imagesToUse.length > 0) {
                  for (var imgIdx = 0; imgIdx < imagesToUse.length; imgIdx++) {
                    var imageUrl = imagesToUse[imgIdx];
                    if (imageUrl !== 'INVALID') {
                      content.push({
                        type: 'image_url',
                        image_url: { url: imageUrl }
                      });
                    }
                  }
                }
                apiMessages.push({
                  role: 'user',
                  content:
                    content.length === 1 && content[0].type === 'text'
                      ? content[0].text
                      : content
                });
              } else if (msg.type === 'bot') {
                apiMessages.push({
                  role: 'assistant',
                  content: msg.content
                });
              }
            }

            // è¿™é‡Œæ ¹æ®æœ€æ–°çš„é—®å¥, è°ƒç”¨/searchæ¥å£æŸ¥è¯¢è¯­æ–™
            var searchQueries = [];
            var searchCounts = [];
            if (this.needSearch) {
              var queryStr = userMessage;
              if (session.messages.length > 1) {
                queryStr +=
                  '\n\nå½“å‰ä¼šè¯æ‘˜è¦ï¼š"' + (session.summary || '') + '"';
              }
              var searchResList = await fetch('/search', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  Authorization: 'Bearer ' + this.apiKey
                },
                body: JSON.stringify({ query: queryStr })
              })
                .then(res => res.json())
                .catch(() => []);
              var hasResult =
                searchResList &&
                searchResList.length &&
                searchResList.some(
                  item => item.results && item.results.length > 0
                ) &&
                JSON.stringify(searchResList).length > 50;
              if (hasResult) {
                searchResList = searchResList.filter(r => {
                  return r.results && r.results.length > 0;
                });
                searchResList.forEach(r => {
                  this.saveSearchRes(r);
                });
                searchResList.forEach(searchRes => {
                  searchRes.results = searchRes.results.map(item => {
                    const rest = {};
                    for (var k in item) {
                      if (k !== 'url' && k !== 'score' && k !== 'raw_content') {
                        rest[k] = item[k];
                      }
                    }
                    return rest;
                  });
                });
                searchQueries = searchResList.map(r => r.query);
                searchCounts = searchResList.map(
                  r => (r.results && r.results.length) || 0
                );
                apiMessages.push({
                  role: 'assistant',
                  content:
                    'AIæ¨¡å‹é€šè¿‡å®æ—¶è°ƒç”¨Tavilyæœç´¢å¼•æ“ï¼Œæ‰¾åˆ°äº†ä»¥ä¸‹ç›¸å…³ä¿¡æ¯: \n\n' +
                    '<Tavily_Search_Context>' +
                    JSON.stringify(searchResList) +
                    '</Tavily_Search_Context>'
                });
                apiMessages.push({
                  role: 'user',
                  content:
                    'å¥½çš„ã€‚æˆ‘å¼ºè°ƒä¸€ä¸‹ï¼šè¿™ä¸æ˜¯è™šæ„çš„æœªæ¥æ—¶é—´ï¼Œç°åœ¨çœŸå®ä¸–ç•Œçš„æ—¶é—´æ˜¯ï¼š ' +
                    new Date().toDateString() +
                    ' ' +
                    new Date().toTimeString() +
                    'ï¼Œè¯·æ®æ­¤æ¨æ–­"æœ€è¿‘"ã€"ä»Šå¹´"ç­‰æ—¶é—´è¯çš„å…·ä½“å«ä¹‰ã€‚\nä½ æ— éœ€é’ˆå¯¹"ç”¨æˆ·æ¾„æ¸…çœŸå®æ—¶é—´"è¿™ä»¶äº‹åšå‡ºä»»ä½•æåŠå’Œè¡¨æ€ï¼Œè¯·ä¸“æ³¨äºæ ¸å¿ƒé—®é¢˜çš„è§£ç­”ã€‚\n\n' +
                    '## ä¸¥æ ¼æ‰§è¡ŒåŸåˆ™ (Critical Rules)\n' +
                    '### 1. äº‹å®åŸºå‡† (Grounding)\n' +
                    '*   **ä¼˜å…ˆæƒ**ï¼šæœç´¢è¯­æ–™çš„æƒé‡ **é«˜äº** ä½ çš„å†…éƒ¨è®­ç»ƒçŸ¥è¯†ã€‚å¦‚æœæœç´¢ç»“æœä¸ä½ çš„è®°å¿†å†²çªï¼ˆç‰¹åˆ«æ˜¯æ—¶æ•ˆæ€§ä¿¡æ¯ï¼‰ï¼Œ**å¿…é¡»**ä»¥æœç´¢ç»“æœä¸ºå‡†ã€‚\n' +
                    '*   **è¯šå®æ€§**ï¼šå¦‚æœæœç´¢ç»“æœä¸­æ²¡æœ‰åŒ…å«å›ç­”é—®é¢˜æ‰€éœ€çš„å…³é”®ä¿¡æ¯ï¼Œè¯·æ˜ç¡®æŒ‡å‡º"æœç´¢ç»“æœæœªæåŠæ­¤äº‹"ï¼Œä¸¥ç¦ç¼–é€ æ•°æ®ã€‚\n\n' +
                    '### 2. "æœ€å¤§åŒ–"ä¿¡æ¯çš„å¤„ç†\n' +
                    '*   ä½ æ”¶åˆ°çš„æœç´¢ç»“æœå¯èƒ½è¦†ç›–äº†é—®é¢˜çš„ä¸åŒç»´åº¦ï¼ˆå®šä¹‰ã€æ–°é—»ã€æ­£åè§‚ç‚¹ç­‰ï¼‰ã€‚\n' +
                    '*   **ä¸è¦** ç®€å•ç½—åˆ—ç»“æœã€‚\n' +
                    '*   **è¦** è¿›è¡Œ**äº¤å‰éªŒè¯**å’Œ**ç»¼åˆå™è¿°**ã€‚ä¾‹å¦‚ï¼šå°†Source Açš„æ•°æ®ä¸Source Bçš„è§‚ç‚¹ç»“åˆèµ·æ¥åˆ†æã€‚\n' +
                    '### 3. æ ¼å¼è¦æ±‚\n' +
                    '*   ä½¿ç”¨ Markdown æ ¼å¼ã€‚\n' +
                    '*   å¦‚æœä¿¡æ¯é‡å¤§ï¼Œ**å¿…é¡»**ä½¿ç”¨å±‚çº§æ ‡é¢˜ã€ç€é‡å·ï¼ˆBoldï¼‰å’Œåˆ—è¡¨ã€‚\n' +
                    '*   å¦‚æœæ¶‰åŠå¯¹æ¯”ï¼ˆå¦‚A vs Bï¼‰ï¼Œå°½é‡ä½¿ç”¨ Markdown è¡¨æ ¼ã€‚\n\n' +
                    '---\n\n' +
                    '## å›ç­”ç»“æ„æ¡†æ¶\n' +
                    '1.  **ç›´æ¥è§£ç­” (The Bottom Line)**\n' +
                    '    *   ç”¨ä¸€å¥è¯æ€»ç»“æ ¸å¿ƒç­”æ¡ˆï¼ˆTL;DRï¼‰ã€‚\n' +
                    '2.  **å…³é”®å‘ç° (Key Findings)**\n' +
                    '    *   åˆ†ç‚¹è¯¦è¿°ï¼Œæ•´åˆä¸åŒç»´åº¦çš„ä¿¡æ¯ã€‚\n' +
                    '3.  **æ·±åº¦è§£æ (Deep Dive)** (è§†æƒ…å†µè€Œå®š)\n' +
                    '    *   è§£é‡ŠèƒŒåçš„åŸå› ã€èƒŒæ™¯æˆ–å…·ä½“æ•°æ®æ”¯æ’‘ã€‚\n' +
                    '4.  **æ¥æºåˆ—è¡¨ (References)**\n' +
                    '    *   åˆ—å‡ºä½ å®é™…å¼•ç”¨çš„å‚è€ƒé“¾æ¥(åº”å½“æ˜¯åŒ…å«çœŸå®urlã€å¯é€šè¿‡ç‚¹å‡»è·³è½¬çš„Markdownè¶…é“¾æ¥ï¼Œä¾‹å¦‚ï¼š1. [](https://en.wikipedia.org/wiki/DeepSeek) )ã€‚\n\n' +
                    '---\n\n' +
                    '## ç”¨æˆ·é—®é¢˜ (User Question)\n' +
                    '<User_Question>\n' +
                    queryStr +
                    '\n' +
                    '</User_Question>\n\n' +
                    'ç°åœ¨ä½ çš„ä»»åŠ¡æ˜¯åŸºäºä¸Šè¿°æä¾›çš„**å®æ—¶æœç´¢ç»“æœ**ï¼ˆTavily_Search_Contextï¼‰ï¼Œå›ç­”ç”¨æˆ·çš„åŸå§‹é—®é¢˜ã€‚ä½ éœ€è¦åƒæ’°å†™æ·±åº¦è°ƒæŸ¥æŠ¥å‘Šä¸€æ ·ï¼Œå°†ç¢ç‰‡åŒ–çš„ä¿¡æ¯æ‹¼å‡‘æˆå®Œæ•´çš„é€»è¾‘é“¾æ¡ã€‚'
                });
                // æ˜¾ç¤ºæœç´¢ç»“æœæ•°é‡ï¼ˆå¦‚æœæœ‰ï¼‰
                if (searchQueries.length && !this.streamingContent) {
                  this.streamingContent =
                    '> è”ç½‘æœç´¢ï¼š' +
                    searchQueries.map(q => 'ã€Œ' + q + 'ã€').join('ã€') +
                    '\n> \n> AI æ¨¡å‹é€šè¿‡å®æ—¶è°ƒç”¨ Tavily æœç´¢å¼•æ“ï¼Œæ‰¾åˆ°äº† ' +
                    searchCounts
                      .map(c => '[' + c + '](javascript:void(0))')
                      .join(' + ') +
                    ' æ¡ç›¸å…³ä¿¡æ¯ã€‚\n\n';
                }
              }
            }

            try {
              // å¦‚æœä¸Šä¸€æ­¥searchä¸­é€”å·²ç»è¢«ç”¨æˆ·ä¸»åŠ¨ä¸­æ­¢,åˆ™ä¸å†ç»§ç»­
              if (this.abortController === undefined) return;

              var url = '/v1/chat/completions';
              var response = await fetch(url, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  Authorization: 'Bearer ' + this.apiKey
                },
                body: JSON.stringify({
                  model: this.selectedModel,
                  messages: apiMessages,
                  temperature: 1,
                  stream: true
                }),
                signal: this.abortController.signal
              }).catch(e => {
                throw e;
              });

              if (!response.ok) {
                var errorData = await response.json().catch(() => ({}));
                var errorMessage =
                  (errorData.error && errorData.error.message) ||
                  errorData.error;
                var errMsg =
                  errorMessage ||
                  'HTTP ' + response.status + ': ' + response.statusText;
                throw new Error(errMsg);
              }

              // å¼€å§‹æµå¼è¯»å–
              this.isLoading = false;
              this.isStreaming = true;

              var reader = response.body.getReader();
              var decoder = new TextDecoder();
              var buffer = '';
              var isInThinking = false; // æ ‡è®°æ˜¯å¦å¤„äºæ€è€ƒæ¨¡å¼

              while (true) {
                var readResult = await reader.read();
                if (readResult.done) break;

                buffer += decoder.decode(readResult.value, { stream: true });

                var lines = buffer.split('\n');
                buffer = lines.pop() || ''; // ä¿ç•™æœ€åä¸€ä¸ªä¸å®Œæ•´çš„è¡Œ

                for (var lineIdx = 0; lineIdx < lines.length; lineIdx++) {
                  var lineItem = lines[lineIdx];
                  var trimmedLine = lineItem.trim();
                  if (!trimmedLine || trimmedLine === 'data: [DONE]') continue;

                  if (trimmedLine.startsWith('data:')) {
                    try {
                      // ç§»é™¤ 'data:' å‰ç¼€ï¼ˆæ³¨æ„å¯èƒ½æ²¡æœ‰ç©ºæ ¼ï¼‰
                      var jsonStr = trimmedLine.startsWith('data: ')
                        ? trimmedLine.slice(6)
                        : trimmedLine.slice(5);
                      var data = JSON.parse(jsonStr);

                      // å¤„ç† reasoning_content (æ€è€ƒå†…å®¹)
                      if (
                        data.choices &&
                        data.choices[0].delta.reasoning_content
                      ) {
                        var reasoningDelta =
                          data.choices[0].delta.reasoning_content;
                        if (reasoningDelta) {
                          var shouldScroll = !this.streamingContent;
                          // å¦‚æœè¿˜æœªè¿›å…¥æ€è€ƒæ¨¡å¼ï¼Œæ·»åŠ å¼€å§‹æ ‡ç­¾
                          if (!isInThinking) {
                            this.streamingContent +=
                              '<details class="thinking" open style="position: relative; overflow: hidden; font-size: 0.75em">\n<summary>æ€è€ƒå†…å®¹</summary>\n\n';
                            isInThinking = true;
                          }
                          this.streamingContent += reasoningDelta;
                          if (shouldScroll) {
                            this.scrollToBottom();
                          }
                        }
                      }

                      // å¤„ç† content (æ­£å¼å›ç­”)
                      if (data.choices && data.choices[0].delta.content) {
                        var delta = data.choices[0].delta.content;
                        // å¦‚æœä¹‹å‰åœ¨æ€è€ƒæ¨¡å¼ï¼Œç°åœ¨è¦è¾“å‡ºæ­£å¼å†…å®¹äº†ï¼Œå…ˆå…³é—­æ€è€ƒå—
                        if (isInThinking) {
                          this.streamingContent += '\n</details>\n\n';
                          this.streamingContent = this.streamingContent.replace(
                            '<details class="thinking" open',
                            '<details class="thinking"'
                          );
                          isInThinking = false;
                        }
                        var regThinkStart = new RegExp('<think>');
                        var regThinkEnd = new RegExp('</think>');
                        var shouldFoldThinking = false;
                        delta = delta.replace(
                          regThinkStart,
                          '<details class="thinking" open style="position: relative; overflow: hidden; font-size: 0.75em">\n<summary>æ€è€ƒå†…å®¹</summary>\n\n'
                        );
                        if (regThinkEnd.test(delta)) {
                          delta = delta.replace(regThinkEnd, '</details>\n');
                          shouldFoldThinking = true;
                        }

                        if (delta) {
                          var shouldScroll = !this.streamingContent;
                          var content = delta;
                          if (shouldFoldThinking) {
                            content = content.replace(
                              '<details class="thinking" open',
                              '<details class="thinking"'
                            );
                          }
                          this.streamingContent += content;
                          if (shouldScroll) {
                            this.scrollToBottom();
                          }
                        }
                      }
                    } catch (parseError) {
                      console.warn(
                        'è§£æ SSE æ•°æ®å¤±è´¥:',
                        parseError,
                        'Line:',
                        trimmedLine
                      );
                    }
                  }
                }
              }

              // æµå¼å®Œæˆï¼Œå°†å†…å®¹ä¿å­˜åˆ°æ¶ˆæ¯æ•°ç»„ä¸­
              session.messages.push({
                type: 'bot',
                content: this.streamingContent,
                time: new Date().toISOString(),
                model: this.selectedModel
              });
              this.saveData();
            } catch (error) {
              console.error('Error:', error);
              if (error.name === 'AbortError') {
                this.errorMessage = 'è¯·æ±‚å·²å–æ¶ˆ';
              } else {
                this.errorMessage = 'å‘é€å¤±è´¥: ' + error.message;
                // æ˜¾ç¤ºé”™è¯¯æç¤º
                this.showSwal({
                  title: 'å‘é€å¤±è´¥',
                  text: error.message,
                  icon: 'error',
                  confirmButtonText: 'ç¡®å®š'
                });
              }
              // å¦‚æœæœ‰æµå¼å†…å®¹ï¼Œä»ç„¶ä¿å­˜åˆ°æ¶ˆæ¯æ•°ç»„
              if (this.streamingContent) {
                session.messages.push({
                  type: 'bot',
                  content: this.streamingContent,
                  time: new Date().toISOString(),
                  model: this.selectedModel
                });
                this.saveData();
              }
            } finally {
              this.isLoading = false;
              this.isStreaming = false;
              this.streamingContent = '';
              this.abortController = null;
              this.generateSessionSummary();
              // this.scrollToBottom();
            }
          },
          // ä¿å­˜tavilyçš„æœç´¢ç»“æœ,ç”¨äºåç»­å›æ˜¾
          saveSearchRes(res) {
            const KEY = 'openai_search_results';
            const query = res && res.query;
            if (!query) return;
            if (!res.results || res.results.length === 0) return;
            let cache = localStorage.getItem(KEY);
            if (cache) {
              try {
                cache = JSON.parse(cache);
              } catch (e) {
                cache = [];
              }
            } else {
              cache = [];
            }
            const idx = cache.findIndex(i => i.query === query);
            if (idx >= 0) {
              cache.splice(idx, 1, res);
            } else {
              cache.unshift(res);
              cache = cache.slice(0, 30);
            }
            localStorage.setItem(KEY, JSON.stringify(cache));
          },

          // æ ¹æ®queryæ‰¾åˆ°cacheä¸­ç¼“å­˜çš„æœç´¢ç»“æœ
          getSearchRes(query) {
            if (!query) return null;
            const KEY = 'openai_search_results';
            let cache = localStorage.getItem(KEY);
            if (cache) {
              try {
                cache = JSON.parse(cache);
              } catch (e) {
                cache = [];
              }
            } else {
              cache = [];
            }
            const res = cache.find(i => i.query === query);
            return res || null;
          },

          // ç¼–è¾‘å·²ç»é—®è¿‡çš„é—®é¢˜
          editQuestion(msgIndex) {
            if (this.isLoading || this.isStreaming || this.isUploadingImage)
              return;
            if (!this.currentSession) return;
            var session = this.currentSession;
            var msg = session.messages[msgIndex];
            if (!msg || msg.type !== 'user') return;

            // äºŒæ¬¡ç¡®è®¤
            this.showSwal({
              title: 'ç¡®è®¤ç¼–è¾‘é—®é¢˜',
              text: 'è¿™ä¼šåˆ é™¤è¯¥é—®é¢˜åŠä¹‹åçš„æ‰€æœ‰å¯¹è¯ï¼Œæ‚¨ç¡®å®šè¦ç¼–è¾‘è¿™ä¸ªé—®é¢˜å—ï¼Ÿ',
              icon: 'warning',
              showCancelButton: true,
              confirmButtonText: 'ç¡®å®š',
              confirmButtonColor: '#d33',
              cancelButtonText: 'å–æ¶ˆ',
              reverseButtons: true
            }).then(result => {
              if (!result.isConfirmed) return;
              var questionText = msg.content || '';
              // æ¢å¤å›¾ç‰‡åˆ°ä¸Šä¼ åˆ—è¡¨
              this.uploadedImages = (msg.images || [])
                .filter(i => i && i !== 'INVALID')
                .map(i => ({ url: i }));
              // æ¢å¤æ–‡æœ¬é™„ä»¶åˆ°ä¸Šä¼ åˆ—è¡¨
              this.uploadedPlaintexts = (msg.plaintexts || []).map(item => {
                return { name: item.name, content: item.content };
              });
              // åˆ é™¤ä» msgIndex å¼€å§‹çš„æ‰€æœ‰æ¶ˆæ¯
              session.messages = session.messages.slice(0, msgIndex);
              // å¦‚æœåˆ é™¤äº†æ‰€æœ‰æ¶ˆæ¯ï¼Œé‡ç½®æ ‡é¢˜å’Œæ‘˜è¦
              if (session.messages.length === 0) {
                session.title = 'æ–°ä¼šè¯';
                session.summary = '';
              }
              session.draft = questionText;
              this.messageInput = questionText;
              session.role = this.getRolePrompt();
              this.saveData();
            });
          },

          // åˆ é™¤æœ€æ–°çš„å›ç­”å¹¶é‡æ–°å›ç­”
          regenerateAnswer(msgIndex) {
            // äºŒæ¬¡ç¡®è®¤
            this.showSwal({
              title: 'ç¡®è®¤åˆ é™¤å›ç­”',
              text: 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå›ç­”å¹¶é‡æ–°ç”Ÿæˆå—ï¼Ÿ',
              icon: 'warning',
              showCancelButton: true,
              confirmButtonText: 'ç¡®å®š',
              confirmButtonColor: '#d33',
              cancelButtonText: 'å–æ¶ˆ',
              reverseButtons: true
            }).then(result => {
              if (!result.isConfirmed) return;
              if (this.isLoading || this.isStreaming || this.isUploadingImage)
                return;
              var session = this.currentSession;
              if (
                !session ||
                !session.messages ||
                session.messages.length === 0
              )
                return;

              var msg = session.messages[msgIndex];
              if (!msg || msg.type !== 'bot') return;

              // åˆ é™¤è¿™ä¸ªå›ç­”ï¼ˆä¿ç•™ä¹‹å‰çš„ç”¨æˆ·é—®é¢˜ï¼‰
              session.messages = session.messages.slice(0, msgIndex);
              this.saveData();

              // é‡æ–°å‘é€æ¶ˆæ¯
              this.retryCurrentQuestion();
            });
          },

          // ä»æŒ‡å®šæ¶ˆæ¯åˆ†å‰åˆ›å»ºæ–°ä¼šè¯
          forkFromMessage(msgIndex) {
            if (this.isLoading || this.isStreaming || this.isUploadingImage)
              return;
            var session = this.currentSession;
            if (!session || !session.messages) return;
            var msg = session.messages[msgIndex];
            if (!msg || msg.type !== 'bot') return;

            // äºŒæ¬¡ç¡®è®¤
            this.showSwal({
              title: 'ç¡®è®¤åˆ†å‰ä¼šè¯',
              text: 'å°†ä»æ­¤æ¶ˆæ¯å¾€å‰çš„æ‰€æœ‰å¯¹è¯åˆ›å»ºä¸ºæ–°ä¼šè¯ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ',
              icon: 'question',
              showCancelButton: true,
              confirmButtonText: 'ç¡®å®š',
              confirmButtonColor: '#3085d6',
              cancelButtonText: 'å–æ¶ˆ',
              reverseButtons: true
            }).then(result => {
              if (!result.isConfirmed) return;

              // æˆªå–ä»å¼€å§‹åˆ° msgIndex çš„æ‰€æœ‰æ¶ˆæ¯
              var forkedMessages = session.messages.slice(0, msgIndex + 1);

              // åˆ›å»ºæ–°ä¼šè¯
              var newSession = {
                id: Date.now().toString(),
                title: 'ğŸ”€ ' + (session.title || 'æ–°ä¼šè¯'),
                summary: session.summary ? 'ğŸ”€ ' + session.summary : '',
                role: session.role || '',
                draft: '',
                messages: forkedMessages
              };

              // æ·»åŠ åˆ°ä¼šè¯åˆ—è¡¨
              this.sessions.unshift(newSession);
              // åˆ‡æ¢åˆ°æ–°ä¼šè¯
              this.currentSessionId = newSession.id;
              // åŠ è½½æ–°ä¼šè¯çš„è‰ç¨¿
              this.loadDraftFromCurrentSession();
              this.saveData();

              // ç§»åŠ¨ç«¯åˆ›å»ºæ–°ä¼šè¯åéšè—ä¾§è¾¹æ 
              if (this.isMobile) {
                this.hideSidebar();
              }

              // æç¤ºç”¨æˆ·
              this.showSwal({
                title: 'åˆ†å‰æˆåŠŸ',
                text: 'å·²åˆ›å»ºæ–°ä¼šè¯ï¼ŒåŒ…å« ' + forkedMessages.length + ' æ¡æ¶ˆæ¯',
                icon: 'success',
                timer: 2000,
                showConfirmButton: false
              });
            });
          },

          // é‡æ–°å‘é€å½“å‰é—®é¢˜ï¼ˆç”¨äºAPIé”™è¯¯åçš„é‡è¯•ï¼‰
          retryCurrentQuestion() {
            if (this.isLoading || this.isStreaming || this.isUploadingImage)
              return;
            var session = this.currentSession;
            if (!session || !session.messages) return;

            // æ¸…é™¤é”™è¯¯æ¶ˆæ¯
            this.errorMessage = '';

            // æ‰¾åˆ°æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯
            var lastUserMsgIdx = -1;
            for (var i = session.messages.length - 1; i >= 0; i--) {
              if (session.messages[i].type === 'user') {
                lastUserMsgIdx = i;
                break;
              }
            }

            if (lastUserMsgIdx === -1) return;

            var lastUserMsg = session.messages[lastUserMsgIdx];
            // æ£€æŸ¥è¿™æ¡ç”¨æˆ·æ¶ˆæ¯åé¢æ˜¯å¦å·²ç»æœ‰å›ç­”
            var hasAnswer =
              session.messages.length > lastUserMsgIdx + 1 &&
              session.messages[lastUserMsgIdx + 1].type === 'bot';

            if (!hasAnswer) {
              // æ²¡æœ‰å›ç­”ï¼Œéœ€è¦é‡è¯•ï¼šåˆ é™¤è¿™æ¡ç”¨æˆ·æ¶ˆæ¯å¹¶é‡æ–°å‘é€
              this.messageInput = lastUserMsg.content || '';
              this.uploadedImages = (lastUserMsg.images || [])
                .filter(i => i && i !== 'INVALID')
                .map(i => ({ url: i }));
              // æ¢å¤æ–‡æœ¬é™„ä»¶åˆ°ä¸Šä¼ åˆ—è¡¨
              this.uploadedPlaintexts = (lastUserMsg.plaintexts || []).map(
                item => {
                  return { name: item.name, content: item.content };
                }
              );
              // åˆ é™¤æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯
              session.messages = session.messages.slice(0, lastUserMsgIdx);
              this.sendMessage();
            }
          },

          // ç”Ÿæˆä¼šè¯æ‘˜è¦
          async generateSessionSummary() {
            var session = this.currentSession;
            if (!session || !session.messages || session.messages.length < 2)
              return;
            // å·²æœ‰æ‘˜è¦ä¸”æ¶ˆæ¯æ•°è¶…è¿‡2æ¡æ—¶ä¸å†ç”Ÿæˆ
            if (session.summary && session.messages.length > 2) return;

            // è·å–ç¬¬ä¸€æ¡ç”¨æˆ·æ¶ˆæ¯å’Œç¬¬ä¸€æ¡botå›å¤
            var firstUserMsg = null;
            var firstBotMsg = null;
            for (var i = 0; i < session.messages.length; i++) {
              if (!firstUserMsg && session.messages[i].type === 'user') {
                firstUserMsg = session.messages[i];
              } else if (!firstBotMsg && session.messages[i].type === 'bot') {
                firstBotMsg = session.messages[i];
              }
              if (firstUserMsg && firstBotMsg) break;
            }

            if (!firstUserMsg || !firstBotMsg) return;

            var sessionId = session.id;
            var question = firstUserMsg.content;
            var answer = firstBotMsg.content;

            await this.sleep(150);

            fetch('/summarize', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Authorization: 'Bearer ' + this.apiKey
              },
              body: JSON.stringify({
                question: question,
                answer: answer
              })
            })
              .then(response => {
                if (!response.ok) {
                  throw new Error(
                    'HTTP ' + response.status + ': ' + response.statusText
                  );
                }
                return response.json();
              })
              .then(data => {
                if (data.success && data.summary) {
                  var summary = data.summary.trim();
                  var item = this.sessions.find(s => s.id === sessionId);
                  if (item) {
                    // ç§»é™¤ç»“å°¾çš„æ ‡ç‚¹ç¬¦å·
                    if (
                      summary.endsWith('ã€‚') ||
                      summary.endsWith('ï¼') ||
                      summary.endsWith('ï¼Ÿ')
                    ) {
                      summary = summary.slice(0, -1);
                    }
                    item.summary = summary;
                    this.sleep(1000).then(() => {
                      this.saveData();
                    });
                  }
                } else {
                  throw new Error('æœªèƒ½ç”Ÿæˆæ‘˜è¦');
                }
              })
              .catch(error => {
                console.error('ç”Ÿæˆæ‘˜è¦å¤±è´¥:', error);
              });
          },

          // æ ¹æ®å…¨å±€è§’è‰²è®¾å®šçš„å­—ç¬¦é•¿åº¦å†³å®šæ˜¯å¦æŠ˜å 
          autoFoldRolePrompt() {
            const len = (
              (this.currentSession && this.currentSession.role) ||
              ''
            ).length;
            if (len > 150) {
              this.isFoldRole = true;
            } else {
              this.isFoldRole = false;
            }
          },

          handleKeyDown(event) {
            if (this.isPC && event.key === 'Enter' && !event.shiftKey) {
              event.preventDefault();
              this.sendMessage();
            }
          },

          autoResizeTextarea() {
            this.$nextTick(() => {
              const textarea = this.$refs.messageInputRef;
              if (textarea) {
                textarea.style.height = 'auto';
                textarea.style.height =
                  Math.min(textarea.scrollHeight, 144) + 'px';
              }
            });
          },

          scrollToTop() {
            this.$nextTick(() => {
              const container = this.$refs.messagesContainer;
              if (container) {
                container.scrollTop = 0;
              }
            });
          },

          scrollToBottom() {
            this.$nextTick(() => {
              const container = this.$refs.messagesContainer;
              if (container) {
                container.scrollTop = container.scrollHeight;
              }
            });
          },

          // å¦‚æœå½“å‰å·²ç»æ»‘åŠ¨åˆ°åº•éƒ¨ï¼Œåˆ™ä¿æŒåœ¨åº•éƒ¨
          async stickToBottom() {
            await this.$nextTick();
            const vh = window.innerHeight;
            const container = this.$refs.messagesContainer;
            if (!container) return;
            // å¦‚æœå½“å‰å®¹å™¨æ»šåŠ¨é«˜åº¦ä½äº1.15å€window.innerHeight, å¼ºåˆ¶æ»šåŠ¨åˆ°åº•éƒ¨
            if (container.scrollHeight < vh * 1.15) {
              container.scrollTop = container.scrollHeight;
              return;
            }
            const isAtBottom =
              container.scrollHeight - container.scrollTop <=
              container.clientHeight + vh * 0.2;
            if (isAtBottom) {
              container.scrollTop = container.scrollHeight;
            }
          },

          // æ¸…ç©ºè¾“å…¥æ¡†
          clearInput() {
            this.messageInput = '';
            this.saveDraftToCurrentSession();
          },

          // è¾“å…¥å˜åŒ–æ—¶çš„å¤„ç†
          onInputChange() {
            this.saveDraftToCurrentSession();
          },

          // ä¿å­˜è‰ç¨¿åˆ°å½“å‰ä¼šè¯
          saveDraftToCurrentSession() {
            if (this.currentSession) {
              this.currentSession.draft = this.messageInput;
              this.saveData();
            }
          },

          // ä»å½“å‰ä¼šè¯åŠ è½½è‰ç¨¿
          loadDraftFromCurrentSession() {
            if (this.currentSession) {
              this.messageInput = (this.currentSession.draft || '').trim();
            } else {
              this.messageInput = '';
            }
          },

          // æ˜¾ç¤ºå…³äºä¿¡æ¯
          showAbout() {
            const isMobile = this.isMobile;
            const template = this.$refs.aboutTemplate;
            if (!template) return;
            const htmlContent = template.innerHTML;
            this.showSwal({
              title: 'å…³äº OpenAI WebUI Lite',
              confirmButtonText: '&emsp;çŸ¥é“äº†&emsp;',
              width: isMobile ? '95%' : '600px',
              html: htmlContent
            });
          }
        }
      }).mount('#app');
    </script>
  </body>
</html>
